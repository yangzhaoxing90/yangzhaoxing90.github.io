[{"content":"第 1 章 关于本书的对话 三个关键概念：\n虚拟化（virtualization）、并发（concurrency）、持久性（persistence） 理解：\n操作系统是如何工作的 操作系统决定解下来哪个程序使用 CPU 如何在虚拟内存系统中处理内存使用过载 虚拟机监控器如何工作 如何管理磁盘上的数据 如果构建在部分节点失败时仍能正常工作的分布式系统 ","date":"2025-03-04T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/cover_hu2911111422562421892.png","permalink":"https://yangzhaoxing90.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/","title":"操作系统导论"},{"content":"第 1 章 引论 ","date":"2025-03-04T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cover_hu11947037081738902335.png","permalink":"https://yangzhaoxing90.github.io/p/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"现代操作系统"},{"content":"资料 https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/index.html\n第 1 章 构造过程抽象 1.1 程序设计的基本元素 三种机制：\n基本表达形式，用于表示语言所关心的最简单的个体 组合的方法，通过它们可以从较简单的东西出发构造出复合的元素 抽象的方法，通过它们可以为复合对象命名，并将它们当作单元去操作 表达式：\n前缀表达式 (+ 1 2) 组合式 (+ (+ 1 2) 3) 命名和环境：\n变量 (define size 2) 环境(全局环境) (值和符号的关联，需要的存储能力) 组合式求解：\n求值该组合式的各个子表达式 将最左子表达式的值的那个过程应用于相应的实际参数，就是其他子表达式的值 树形累积 （如图） 特殊形式：\ndefine 每种特殊形式都有自身的求值规则 复合过程：\n数和运算是基本的数据和过程 组合式的嵌套提供了一种组织起多个操作的方法 定义是一种受限抽象手段，它为名字关联相应的值 过程定义:\n威力更强大的抽象技术 通过它可以为复合操作提供名字 (define (square x) (* x x)) (square 3) 代换模型 （解释器的代换模型）\n将实参代入过程运算，转换为组合式的运算 正则序和应用序：\n正则序（完全展开后归约） 应用序 (先求值参数而后应用) 条件表达式和谓词\ncond cond 后跟着对偶式，(p e) else if (if p consequent alternative) and (e1, e2, \u0026hellip;, en) or (e1, e2, \u0026hellip;, en) not (e) 内部定义和块结构\ndefine 嵌套 词法作用域 1.2 过程与它们所产生的计算 线性的递归和迭代：\n线性递归过程 （计算长度随轨迹线性增长） 线性迭代过程 （计算长度不会随轨迹增长，状态可以用固定数目的状态变量描述的计算过程） 树形递归：\n斐波那契数的例子 增长的阶:\n不同的计算过程在消耗资源和计算资源的速率上可能存在巨大差异，用增长的阶来描述这种差异 $n$ 做为问题规模的度量，$R(n)$ 是一个计算过程在处理规模为 $n$ 的问题时所需的资源量 我们称 $R(n)$ 具有 $\\theta(f(n))$ 的增长阶，记为 $R(n) = \\theta(f(n))$,若存在 $k1$ 和 $k2$ 使得 $k1f(n) $ ","date":"2025-03-04T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A/cover_hu14020803940582502411.png","permalink":"https://yangzhaoxing90.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A/","title":"计算机程序的构造和解释"},{"content":"概述 第1章 导论 操作系统是管理计算机硬件的程序,它还为应用程序提供基础，充当计算机硬件和用户之间的中介\n本章目标：\n概括介绍操作系统的主要组件 概括介绍计算机系统的基本组织体系结构 1.1 操作系统做什么 计算机系统可以粗分为 4 个组成部分：\n计算机硬件 （如CPU、内存、IO设备），为系统提供基本的计算资源 操作系统 控制和协调用户的应用程序对硬件的使用 系统程序、应用程序 （如 word、浏览器），规定了按照何种方式使用资源解决用户的问题 用户 1.2 计算机系统组织 计算机系统操作\n电脑启动 -\u0026gt; 初始化程序 (位于固件中) -\u0026gt; 引导程序定位操作系统内核，并把它装入内存 -\u0026gt; 操作系统执行第一个进程，如 init -\u0026gt; 等待事件发生\n事件的发送：\n硬件中断 （随时通过系统总线向 CPU 发出信号，以触发中断） 软件中断 （通过执行系统调用） CPU 执行 IO 中断，然后又恢复原来的进程执行\n不同的计算机有不同的中断机制，共同的点是，中断必须将控制权交给合适的中断服务历程\n存储结构\nIO结构\n通用计算机系统由一个CPU和多个设备控制器组成，它们通过共同的总线连接起来。每个设备控制器负责特定类型的设备\n通常操作系统为每个设备控制器提供一个设备驱动程序，设备驱动程序理解设备控制器，提供设备和操作系统之间统一的接口\n为了开始 IO 操作，设备驱动程序在设备控制器中装载适当的寄存器，设备控制器检查这些寄存器的内容，以确定执行什么操作\n这种 IO 中断驱动适合移动少量数据，但对于大量数据的移动，会带来超载问题，DMA （直接内存访问） 就是为了解决这个问题设计的\n1.3 计算机系统体系结构 单处理器系统 多处理器系统 1.4 操作系统结构 多道程序能力：\n分时系统 （CPU 来回切换执行任务） 分时系统在主存储器中保存几个作业，作业最开始存在于磁盘的作业池中\n操作系统通过作业调度从作业池中选择作业加载入内存，这一决策过程叫做 CPU 调度\n分时操作系统中，操作系统必须保证合理的响应时间，这有时通过交换来得到，其中进程被换入内存或由内存换出到磁盘\n虚拟内存（主要优点是程序可以比物理内存大）\n分时系统也提供文件系统\n1.5 操作系统操作 双重模式操作\n用户模式 内核模式 可以区分操作系统所执行的任务和用户所执行的任务\n双重模式操作为人们提供了保护操作系统和用户程序不受错误用户程序影响的手段\n实现方式为：将能引起损害的机器指令作为特权指令， 硬件允许特权指令仅在内核模式下执行\n定时器：\n必须确保操作系统能维持对CPU的控制，也必须防止用户程序陷入死循环或不调用系统服务，并且不将控制权返回到操作系统\n可将定时器设置为在给定时间后中断计算机，时间可以是固定的，也可以是可变的\n1.6 进程管理 处于执行中的程序被称为进程\n进程需要一定的资源，CPU时间、内存、文件、I/O设备来完成其任务\n操作系统负责管理进程的如下活动：\n创建和删除用户进程和系统进程 挂起和重启进程 提供进程同步机制 提供进程通信机制 提供死锁处理机制 1.7 内存管理 内存是一个大的字或字节的数组，每个字或字节都有自己的地址\n内存是可以被 CPU 和 I/O 设备所共同快速访问的数据仓库\n操作系统负责下列有关内存的活动：\n记录内存的哪部分正在被使用以及被谁使用 当有内存空间时，决定哪些进程可以装入内存 根据需要释放分配和释放内存空间 1.8 存储管理 操作系统对存储设备的物理属性进行了抽象，定义了逻辑存储单元，就是文件\n文件是由其创建者定义的一组相关信息的集合 （程序和数据）\n操作系统负责下列有关文件管理的活动：\n创建和删除文件 创建和删除目录来组织文件 提供操作文件和目录的原语 将文件映射到二级存储上 在稳定（非易失的）存储介质上备份文件 现代大多数操作系统都采用硬盘作为主要在线存储介质来存储程序和数据\n操作系统负责下列有关硬盘管理的活动：\n空闲空间管理 存储空间分配 硬盘调度 1.9 保护和安全 保护是一种控制进程或用户对计算机系统资源访问的机制\n绝大多数操作系统维护一种用户名和相关用户标识（UID）的链表，这些数值对用户来说是唯一的\n1.10 分布式系统 分布式系统是一组物理上分开的、可能各个异构的计算机系统通过网络连接在一起，为用户提供系统所维护的各种资源的计算机的集合\n1.11 专用系统 实时嵌入系统 （运行实时操作系统，有明确切固定的时间约束） 多媒体系统 （多媒体数据必须根据确定的时间限制来传输流） 手持系统 （） 1.12 计算环境 传统环境 批处理计算机系统，以批量的方式处理作业 分时系统采用定时器和调度算法，通过CPU迅速地循环进程，给其中每一个用户分配资源 客户-服务器计算 对等计算 基于 web 计算 第 2 章 操作系统结构 本章目标：\n介绍操作系统为用户、进程和其他系统提供的服务 讨论组织操作系统的不同方法 解释如何安装、定制操作系统，以及如何启动操作系统 2.1 操作系统服务 一组操作系统服务提供对用户很有用的功能：\n用户界面 （GUI、CLI、批界面） 程序执行 （系统必须能将程序装入内存并运行该程序） I/O操作 （运行程序需要的 IO） 文件系统操作 （读写文件和目录） 通信 （进程间交换信息） 错误检测 资源分配 （多个用户或作业运行时，需要分配资源） 统计 （记录哪些用户使用了哪些资源） 保护和安全 2.2 操作系统的用户界面 命令解释程序 图形用户界面 2.3 系统调用 系统调用是获取操作系统所提供的服务的接口\n应用程序员最常用的 API 有三种：\nWin32 API （Windows 系统） POSIX API （Unix、Linux 和 Mac OS X） Java API （JVM） 用 API 不用实际系统调用的好处：\n可移植性强 实际的系统调用比 API 难用且更复杂 2.4 系统调用类型 系统调用可以分为 5 大类：\n进程控制 （结束、放弃、装入、执行、创建进程、终止进程、取得进程属性、设置进程属性、等待时间、等待事件、唤醒事件、分配和释放内存） 文件管理 （创建文件、删除文件、打开、关闭、读、写、重定位、取得文件属性、设置文件属性） 设备管理 （请求设备、释放设备、读、写、重定位、取得设备属性、设置设备属性、逻辑连接或断开设备） 信息维护 （读取时间或日期、设置时间或日期、读取系统数据、设置系统数据、读取进程，文件或设备属性、设置进程，文件或设备属性） 通信 （创建，删除通信连接、发送，接收消息、传递状态信息、连接或断开远程设备） 通信\n两种常见的通信模型：\n消息传递模型 （通信进程通过交换消息来传递信息） 共享内存模型 （通过 shared memory create 和 shared memory attach 系统调用来获得其他进程所拥有的内存区域访问权） 2.5 系统程序 可以分为分类：\n文件管理 状态信息 文件修改 程序设计语言支持 程序装入和执行 通信 2.6 操作系统设计和实现 策略和机制的分离\n机制决定了如何做，策略决定做什么\n2.7 操作系统结构 MS-DOS 结构\n分层结构\n模块结构\n调度类 文件系统 可加载的系统调用 可执行的格式 STREAMS 模块 杂项模块 设备和总线驱动程序 2.8 虚拟机 虚拟机的基本思想是单个计算机的硬件抽象为几个不同的执行环境\n2.9 Java Java 技术包含三个核心组件：\n编程语言规范 应用程序接口 （API） 虚拟机规范 2.10 操作系统生成 下面的信息必须确定下来：\n使用什么 CPU，安装什么选项，对于多 CPU 系统，必须描述每个 CPU 有多少可用内存 有什么可用设备 需要什么操作系统选项或使用什么参数值 2.11 系统启动 第二部分 进程管理 第 3 章 进程 本章目标：\n介绍进程的概念——执行中的程序，形成所有计算的基础 介绍进程的不同特点，包括调度、创建和终止以及通信 介绍客户机——服务机系统内的通信 3.1 进程概念 进程：\n程序代码 （文本段 text section） 活动 （程序计数器的值和处理器寄存器的内容） 进程栈（包括临时数据，函数参数、返回地址、局部变量） 数据段 （data section） 堆 （heap），进程在运行期间动态分配的内存 进程的状态：\n新建 运行 等待 就绪 终止 进程控制块 (PCB)\n进程状态 程序计数器 （表示下一个指令执行的地址） CPU 寄存器 CPU 调度信息 （进程优先级、调度队列的指针和其他调度参数） 内存管理信息 （基址和界限寄存器的值、页表或段表） 记账信息 （CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量） I/O 状态信息 （I/O设备列表、打开文件列表等） 3.2 进程调度 调度队列： 进程进入系统时，会被加到作业队列中，该队列中包含所有的进程\n新进程开始处于就绪队列，它就在队列中等待直到被选中执行或分派\n当进程分配到 CPU 并执行时，可能发生下面几种事件中的一种：\n进程可能发出一个 I/O 请求，并被放到 I/O 队列中 进程可能创建一个新的子进程，并等待结束 进程可能会由于中断而强制释放 CPU， 并被放回就绪队列 调度程序：从队列中选择进程的程序\n上下文切换：CPU从一个进程切换到另一个进程\n内核将旧进程的内容保存到 PCB 中 装入经调度要执行的已保存的新进程的上下文 3.3 进程操作 进程创建：\n系统调用创建进程，父子进程，进程树，进程唯一标识 当进程创建进程时，有两种可能：\n父进程与子进程并发执行 父进程等待，直到某个或全部子进程执行完毕 新进程的地址空间也有两种可能：\n子进程是父进程的副本 子进程装入一个新程序 进程终止：\nexit()请求操作系统删除自身 子进程可以返回状态到父进程 父进程终止子进程的原因：\n子进程使用了超过它所分配到的一些资源 分配给子进程的任务已不再需要 父进程结束，若父进程终止，操作系统将不允许子进程继续 3.4 进程间的通信 允许进程协作的理由：\n信息共享 （并发访问一个资源） 加快计算 模块化 方便 （单用户可以执行多任务） 进程通信的两个基本模型：\n共享内存 消息传递 共享内存模型：\n生产者 —— 消费者问题 无限缓冲区 （消费者要等待新的项，生产者总可以产生新的项） 有限缓冲区 （如果缓冲区为空，消费者必须等待。如果缓冲区满，生产者必须等待） 消息传递模型：\n消息传递工具 （必须提供发送和接收功能） 若进程间要彼此发送消息和接收消息，它们间必须有通信链路 实现链路发送和接收操作的方法：\n直接或间接通信 同步或异步通信 自动或显式缓冲 直接通信：\n必须明确的命名通信的接收者或者发送者 （对称寻址） send(P, message): 发送消息到 P receive(Q, message): 接收来自 Q 的消息 通信链路要求 在需要通信的每队进程间自动建立通信链路，进程只需要知道互相的标识符 一个通信链路只与两个进程相关 每队进程间只有一个通信链路 只需要发送者命名接收者，不需要接收者命名发送者 （非对称寻址） send(P, message): 发送消息到 P receive(id, message): 接收来自任何进程的消息，变量 id 设置成与其通信的进程名称 间接通信：\n通过邮箱和端口来发送和接收消息 邮箱可以抽象成一个对象，进程可以向其中存放消息，也可以从中删除消息 每个邮箱都有一个唯一标识 send(A, message): 发送一个消息到邮箱 A receive(A, message): 接收来自邮箱 A 的消息 通信链路要求 只有在两个进程共享一个邮箱的时候才能建立通信链路 一个链路可以和两个或者更多的进程相关联 两个通信进程之间可以有多条不同的链路，每条链路对应于一个邮箱 假设 P1、P2、P3 都共享邮箱，P1 发送消息到邮箱，P2 和 P3 谁能接收到信息，由系统定义决定：\n允许一个链路最多只能与两个进程相关联 允许一次最多一个进程执行 receive() 操作 允许系统随意选择一个进程接收消息 邮箱可以为进程所拥有：\n进程地址空间的一部分 进程终止时，邮箱消失，往邮箱发送消息会被通知邮箱不存在 邮箱也可以为操作系统所拥有，操作系统必须提供的机制：\n创建新邮箱 （创建的进程默认为进程拥有者） 通过邮箱发送和接收消息 删除邮箱 send、receive 原语实现有不同的设计选项（同步-阻塞、异步-非阻塞）：\n阻塞发送 非阻塞发送 阻塞接收 非阻塞接收 通信进程所交换的消息都驻留在临时队列中，队列实现的3个方法：\n零容量 有限容量 无限容量 3.5 IPC 系统的实例 3.6 客户机 —— 服务器通信 三种客户机——服务器通信方法：\n套接字 （socket），比较低级的分布式进程通信，只允许通信线程交换无结构字节流。 远程过程调用 （RPC） Java的远程方法调用（RMI） 第 4 章 线程 本章目标：\n引入线程的概念 —— 一种 CPU 利用的基本单元，它是形成多线程计算机的基础 讨论 Pthread API 、Win32 API 和 Java 线程库 研究有关多线程编程的几个问题 4.1 概述 线程是 CPU 使用的基本单元，由线程ID、程序计数器、寄存器集合和栈组成\n4.2 多线程模型 线程支持的两种方法：\n用户层的用户线程 内核层的内核线程 4.3 线程库 线程库为程序员提供创建和管理线程的 API\n两种方法实现线程库：\n在用户空间中提供一个没有内核支持的库 执行一个由操作系统直接支持的内核级的库 三种线程库：\nPOSIX Pthread （Unix/Linux） Win32 （Windows） Java （利用前两个） 4.4 Java 线程 Java 线程状态：\n新建 可运行 阻塞 死亡 4.5 多线程问题 线程取消：\n是在线程完成之前终止线程的任务 异步取消 （立即终止目标线程） 延迟取消 （目标线程不断的检查它是否应终止） 信号处理：\n信号在 Unix 中用于通知进程某个特定事件的发生 信号模式： 信号是由特定事件的发生所产生的 产生的信号要发送到进程 一旦发送，信号必须加以处理 线程池：\n单线程执行器 （大小为 1 的线程池） 固定线程执行器 （大小固定的线程池） 缓冲线程执行器 （无限制的线程池） 线程特定数据：\n每个线程需要一定的数据自我副本 （ThreadLocal） ","date":"2025-02-27T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-java%E5%AE%9E%E7%8E%B0/cover_hu12796159741562647631.png","permalink":"https://yangzhaoxing90.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-java%E5%AE%9E%E7%8E%B0/","title":"操作系统概念-Java实现"},{"content":"准备资料 《Java NIO》 O‘Reilly\n","date":"2025-02-26T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/java-nio/cover_hu17967200875576299560.png","permalink":"https://yangzhaoxing90.github.io/p/java-nio/","title":"Java NIO"},{"content":"https://flask.palletsprojects.com/en/stable/\n","date":"2025-02-25T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/flask/cover_hu1496414122402609516.png","permalink":"https://yangzhaoxing90.github.io/p/flask/","title":"Flask"},{"content":"资料 https://cn.vuejs.org/guide/introduction\n什么是 Vue？ 1 2 3 4 5 6 7 8 9 import { createApp, ref } from \u0026#39;vue\u0026#39; createApp({ setup() { return { count: ref(0) } } }).mount(\u0026#39;#app\u0026#39;) 1 2 3 4 5 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt; Count is: {{ count }} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; Vue 的两个核心功能：\n声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系 响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM 渐进式框架 根据你的需求场景，你可以用不同的方式使用 Vue：\n无需构建步骤，渐进式增强静态的 HTML 在任何页面中作为 Web Components 嵌入 单页应用 (SPA) 全栈 / 服务端渲染 (SSR) Jamstack / 静态站点生成 (SSG) 开发桌面端、移动端、WebGL，甚至是命令行终端中的界面 单文件组件 我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，英文 Single-File Components，缩写为 SFC)\n顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。下面我们将用单文件组件的格式重写上面的计数器示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;Count is: {{ count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; button { font-weight: bold; } \u0026lt;/style\u0026gt; API 风格 Vue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API\n互动教程 https://cn.vuejs.org/tutorial/#step-1\n声明式渲染 Attribute 绑定 (v-bind, :id) 事件监听 (v-on, @click) 表单绑定 (v-model) 条件渲染 (v-if, v-else) 列表渲染 (v-for) 计算属性 (computed()) 生命周期和模板引用 (ref, onMounted, onUpdated) 生命周期图 https://cn.vuejs.org/guide/essentials/lifecycle#lifecycle-diagram\n侦听器 (watch) 组件 (import ChildComp from \u0026lsquo;./ChildComp.vue\u0026rsquo;) Props (defineProps) Emits (defineEmits) 插槽 (slot) 快速上手 npm vue-official vite CDN\n1 \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 通过 CDN 使用 Vue 时，不涉及“构建步骤”。这使得设置更加简单，并且可以用于增强静态的 HTML 或与后端框架集成。但是，你将无法使用单文件组件 (SFC) 语法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script src=\u0026#34;https://unpkg.com/vue@3/dist/vue.global.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;{{ message }}\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const { createApp, ref } = Vue createApp({ setup() { const message = ref(\u0026#39;Hello vue!\u0026#39;) return { message } } }).mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; ","date":"2025-02-25T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/vue/cover_hu12612385353832632954.png","permalink":"https://yangzhaoxing90.github.io/p/vue/","title":"Vue"},{"content":"自学成为数学大师 课程内容 资料 学习情况 预计完成 线性代数 georgi-shilov-linear-algebra4、《Linear Algebra Done Right》Axler 未完成 03-24 数学分析 《Understanding Analysis》Abbott + 《Baby Rudin》 \u0026hellip; \u0026hellip; 抽象代数 《A Book of Abstract Algebra》Pinter 概率论 \u0026hellip; \u0026hellip; \u0026hellip; 测度论 《Real Analysis》Stein \u0026hellip; \u0026hellip; 泛函分析 《Functional Analysis》Rudin \u0026hellip; \u0026hellip; 范畴论 《Category Theory in Context》Riehl \u0026hellip; \u0026hellip; 交换代数 Atiyah-MacDonald \u0026hellip; \u0026hellip; 几何拓扑 《拓扑学》（Munkres）、《微分几何》Do Carmo \u0026hellip; \u0026hellip; 数值分析 《Numerical Recipes》+ SciPy实践 \u0026hellip; \u0026hellip; 数学物理 《物理学家的几何方法》Frankel \u0026hellip; \u0026hellip; 参与 Project Euler 解决数学编程问题 每周完成 3-5 道 ProofWiki 挑战题\n自学成为计算机科学家 https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md\n课程内容 资料 学习情况 预计完成 编程 《计算机程序的构造和解释》 \u0026hellip; \u0026hellip; 计算机系统结构 《深入理解计算机系统》 \u0026hellip; \u0026hellip; 算法与数据结构 《算法设计手册》 \u0026hellip; \u0026hellip; 数学知识 《计算机科学中的数学》 \u0026hellip; \u0026hellip; 操作系统 《操作系统导论》 \u0026hellip; \u0026hellip; 计算机网络 《计算机网络：自顶向下方法》 \u0026hellip; \u0026hellip; 数据库 Readings in Database Systems \u0026hellip; \u0026hellip; 编程语言与编译器 Crafting Interpreters \u0026hellip; \u0026hellip; 分布式系统 《数据密集型应用系统设计》 \u0026hellip; \u0026hellip; 自学成为算法大师 https://blog.shahjalalshohag.com/topic-list/\nhttps://youkn0wwho.academy/topic-list\n课程内容 资料 学习情况 预计完成 Basics \u0026hellip; \u0026hellip; \u0026hellip; Data Structures (DS) \u0026hellip; \u0026hellip; \u0026hellip; Graph Theory \u0026hellip; \u0026hellip; \u0026hellip; Number Theory \u0026hellip; \u0026hellip; \u0026hellip; Combinatorics \u0026hellip; \u0026hellip; \u0026hellip; Math \u0026hellip; \u0026hellip; \u0026hellip; Strings \u0026hellip; \u0026hellip; \u0026hellip; Dynamic Programming (DP) \u0026hellip; \u0026hellip; \u0026hellip; Game Theory \u0026hellip; \u0026hellip; \u0026hellip; Geometry \u0026hellip; \u0026hellip; \u0026hellip; Miscellaneous \u0026hellip; \u0026hellip; \u0026hellip; Useful Links \u0026hellip; \u0026hellip; \u0026hellip; 自学成为英语大师 先坚持每日一篇文章吧\nhttps://www.bbc.com/news\nhttps://news.ycombinator.com/\nhttps://www.theverge.com/\n","date":"2025-02-24T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E8%87%AA%E5%AD%A6%E6%8C%87%E5%8D%97/cover_hu10281435386864507294.jpg","permalink":"https://yangzhaoxing90.github.io/p/%E8%87%AA%E5%AD%A6%E6%8C%87%E5%8D%97/","title":"自学指南"},{"content":"单聊系统的实现 A 要和 B 聊天，首先 A 和 B 需要与服务端建立连接，然后进入登录流程，服务端保存用户标识和 TCP 连接的映射关系 A 给 B 发消息，首先需要将带有 B 标识的消息数据包发送到服务端，然后服务端从消息数据包中获得 B 的标识，找到对应 B 的连接，将消息发送给 B 任意一方发消息给对方，如果对方不在线，则需要将消息缓存，在对方上线之后再发送 单聊的指令 Netty 如何启动服务端？ 如何启动客户端？ 数据载体 ByteBuf 如何设计长连接自定义协议？ 拆包/粘包原理与实践 如何实现自定义编解码 如何使用Pipeline与ChannelHandler 如何定时发心跳数据包 如何进行连接空闲检测 Netty Server 基本结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // boss 线程, 监听 OP_ACCEPT 事件 NioEventLoopGroup bossGroup = new NioEventLoopGroup(); // worker 线程, 监听客户端连接的 OP_READ 和 OP_WRITE 事件, 处理 I/O 事件 NioEventLoopGroup workerGroup = new NioEventLoopGroup(); ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap .group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer\u0026lt;NioSocketChannel\u0026gt;() { @Override protected void initChannel(NioSocketChannel nioSocketChannel) { } }); serverBootstrap.bind(8000); Netty Client 基本结构 1 2 3 4 5 6 7 8 9 10 11 12 13 NioEventLoopGroup workerGroup = new NioEventLoopGroup(); Bootstrap bootstrap = new Bootstrap(); bootstrap .group(workerGroup) .channel(NioSocketChannel.class) .handler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;() { @Override protected void initChannel(SocketChannel socketChannel) { } }); bootstrap.connect(\u0026#34;localhost\u0026#34;, 8000); ByteBuf 介绍 ByteBuf 是一个字节容器，容器里面的数据分为三部分:\n第一部分是已经丢弃的字节，这部分数据是无效的 (index \u0026lt; readerIndex) 第二部分是可读字节，这部分数据是 ByteBuf 的主体数据，从 ByteBuf 里读取的数据都来自这一部分 (index \u0026gt;= readerIndex \u0026amp;\u0026amp; index \u0026lt; writerIndex) 最后一部分的数据是可写字节，所有写到 ByteBuf 的数据都会写到这一段 (index \u0026gt; writerIndex) 后面的虚线部分表示该 ByteBuffer 最多还能扩容多少容量 容量相关 API 介绍:\n1 2 3 4 5 6 7 8 9 capacity() // 表示 ByteBuf 底层占用了多少字节的内存 maxCapacity() // 表示 ByteBuf 底层最大能够占用多少字节的内存 readableBytes() // ByteBuf当前可读的字节数 = writerIndex - readerIndex isReadable() // 还有没有可读的字节, 返回 true 或 false writableBytes() // ByteBuf当前可写的字节数 = capacity - writerIndex isWritable() // 还有没有可写的字节, 返回 true 或 false maxWritableBytes() // 可写的最大字节数 = maxCapatiy - writerIndex 读写指针相关的 API 介绍:\n1 2 3 4 5 6 7 8 9 10 11 12 readerIndex() // 返回当前的读指针 readerIndex readerIndex(int) // 设置读指针 writeIndex() // 返回当前的写指针 writerIndex writeIndex(int) // 设置写指针 markReaderIndex() // 把当前的读指针保存起来 resetReaderIndex() // 把当前的读指针恢复到之前保存的值 markWriterIndex() // 把当前的写指针保存起来 resetWriterIndex() // 把当前的写指针恢复到之前保存的值 读写 API 介绍:\n1 2 3 4 5 6 7 8 9 writeBytes(byte[​] src) // 把字节数组 src 里的数据全部写到 ByteBuf readBytes(byte[​] dst) // 把 ByteBuf 里的数据全部读取到 dst writeByte(byte b) // 往 ByteBuf 中写一字节 readByte() // 从 ByteBuf 中读取一字节 writeBoolean()、writeChar()、writeShort()、writeInt()、writeLong()、writeFloat()、writeDouble() readBoolean()、readChar()、readShort()、readInt()、readLong()、readFloat()、readDouble() ... 与读写 API 类似的 API 还有 getBytes()、getByte()与setBytes()、setByte()系列，唯一的区别就是get、set不会改变读写指针，而read、write会改变读写指针，这一点在解析数据的时候千万要注意\n由于Netty使用了堆外内存，而堆外内存是不被JVM直接管理的, 也就是说，申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收\n1 2 release() retain() 在通常情况下，这三个方法会被放到一起比较，三者的返回值分别是一个新的ByteBuf对象\n1 2 3 4 5 slice() // 从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex duplicate() // 把整个ByteBuf都截取出来，包括所有的数据、指针信息 copy() // 客户端与服务端通信协议编解码 协议指的就是客户端与服务端事先商量好的，每一个二进制数据包中的每一段字节分别代表什么含义的规则\n第一个字段是魔数，通常情况下为固定的几字节（这里规定为4字节）有了这个魔数之后，服务端首先取出前面4字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，出于安全考虑，可以直接关闭连接以节省资源\n接下来的1字节为版本号，通常情况下是预留字段，在协议升级的时候用到\n第三部分的序列化算法表示如何把Java对象转换为二进制数据及二进制数据如何转换回Java对象，比如Java自带的序列化、JSON、Hessian等序列化方式\n第四部分的字段表示指令，这里我们用1字节来表示，最高支持256种指令，对于这个即时聊天系统来说已经完全足够了\n第五部分的字段表示数据长度，占4字节\n最后一部分为数据内容，每一种指令对应的数据都是不一样的，比如登录的时候需要用户名和密码，收消息的时候需要用户标识和具体消息内容等\nJava 对象的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Data public abstract class Packet { /** * 协议的版本 */ private Byte version = 1; /** * 指令 */ public abstract Byte getCommand(); } public class LoginRequestPacket extends Packet { @Override public Byte getCommand() { return Command.LOGIN_REQUEST; } } public interface Command { Byte LOGIN_REQUEST = 1; } 序列化的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public interface Serializer { /** * JSON 序列化 */ byte JSON_SERIALIZER = 1; Serializer DEFAULT = new JsonSerializer(); byte getSerializerAlgorithm(); byte[] serialize(Object object); \u0026lt;T\u0026gt; T deserialize(Class\u0026lt;T\u0026gt; clazz, byte[] bytes); } public class JsonSerializer implements Serializer { @Override public byte getSerializerAlgorithm() { return SerializerAlgorithm.JSON; } @Override public byte[] serialize(Object object) { return JSON.toJSONBytes(object); } @Override public \u0026lt;T\u0026gt; T deserialize(Class\u0026lt;T\u0026gt; clazz, byte[] bytes) { return JSON.parseObject(bytes, clazz); } } 编解码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public class PacketCodeC { private static final int MAGIC_NUMBER = 0x12345678; public ByteBuf encode(Packet packet) { ByteBuf byteBuf = ByteBufAllocator.DEFAULT.ioBuffer(); byte[] bytes = Serializer.DEFAULT.serialize(packet); // 1. 魔法数 4byte byteBuf.writeInt(MAGIC_NUMBER); // 2. 版本 1byte byteBuf.writeByte(packet.getVersion()); // 3. 序列化算法 1byte byteBuf.writeByte(Serializer.DEFAULT.getSerializerAlgorithm()); // 4. 指令 1byte byteBuf.writeByte(packet.getCommand()); // 5. 数据长度 4byte byteBuf.writeInt(bytes.length); // 6. 数据 N byte byteBuf.writeBytes(bytes); return byteBuf; } public Packet decode(ByteBuf byteBuf) { // 跳过魔法数 byteBuf.skipBytes(4); // 跳过版本号 byteBuf.skipBytes(1); // 序列化算法标识 byte serializeAlgorithm = byteBuf.readByte(); // 指令 byte command = byteBuf.readByte(); // 数据包长度 int length = byteBuf.readInt(); byte[] bytes = new byte[length]; byteBuf.readBytes(bytes); Class\u0026lt;? extends Packet\u0026gt; requestType = getRequestType(command); Serializer serializer = getSerializer(serializeAlgorithm); if (requestType != null \u0026amp;\u0026amp; serializer != null) { return serializer.deserialize(requestType, bytes); } return null; } private Class\u0026lt;? extends Packet\u0026gt; getRequestType(byte command) { return LoginRequestPacket.class; } private Serializer getSerializer(byte serializeAlgorithm) { return Serializer.DEFAULT; } } 实现客户端登录 实现客户端与服务端收发消息 如何判断客户端是否已经登录？\nPipeline 与 ChannelHandler ChannelInboundHandler: 它是处理读数据的逻辑\nChannelOutboundHandler: 处理写数据的逻辑\nChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 是默认实现\naddLast() 能让 InHandler 的顺序与书面顺序保持一致\naddList() 让 OutHandler 的顺序与书面顺序相反\n是一个双向链表\n特殊的 ChannelHandler ChannelInboundHandlerAdapter (read) ChannelOutboundHandlerAdapter (write) ByteToMessageDecoder (decode) (好处，netty 会自动帮我们释放 ByteBuf 用到的堆外内存) MessageToByteEncoder (encode) SimpleChannelInboundHandler (channelRead0) 拆包/粘包理论与解决方案 存在3种类型的输出:\n一种是正常的字符串输出 一种是多个字符串“粘”在了一起，我们定义这种ByteBuf为粘包 一种是一个字符串被“拆”开，形成一个破碎的包，我们定义这种ByteBuf为半包 为什么会有粘包、半包现象:\n尽管我们的应用层按照ByteBuf为单位来发送数据，但是到了底层操作系统，仍然是按照字节流发送数据的\n因此，数据到了服务端，也按照字节流的方式读入，然后到了Netty应用层面，重新拼装成ByteBuf\n这里的ByteBuf与客户端按照顺序发送的ByteBuf可能是不对等的\n因此，我们需要在客户端根据自定义协议来组装应用层的数据包，然后在服务端根据应用层的协议来组装数据包\n这个过程通常在服务端被称为拆包，而在客户端被称为粘包\n拆包和粘包是相对的，一端粘了包，另外一端就需要将粘过的包拆开\n举个例子，发送端将三个数据包粘成两个TCP数据包发送到接收端，接收端就需要根据应用协议将两个数据包重新拆分成三个数据包\n拆包的原理\n在没有Netty的情况下，用户如果自己需要拆包，基本原理就是不断地从TCP缓冲区中读取数据，每次读取完都需要判断是否是一个完整的数据包\n如果当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从TCP缓冲区中读取，直到得到一个完整的数据包\n如果当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，构成一个完整的业务数据包传递到业务逻辑，多余的数据仍然保留，以便和下次读到的数据尝试拼接\nNetty自带的拆包器 固定长度的拆包器 FixedLengthFrameDecoder\n如果应用层协议非常简单，每个数据包的长度都是固定的, 比如100\n那么只需要把这个拆包器加到Pipeline中，Netty就会把一个个长度为100的数据包（ByteBuf）传递到下一个ChannelHandler\n行拆包器LineBasedFrameDecoder\n发送端发送数据包的时候，每个数据包之间以换行符作为分隔\n接收端通过 LineBasedFrameDecoder 将粘过的ByteBuf拆分成一个个完整的应用层数据包\n分隔符拆包器 DelimiterBasedFrameDecoder\n行拆包器的通用版本，只不过我们可以自定义分隔符 基于长度域的拆包器 LengthFieldBasedFrameDecoder\n最后一种拆包器是最通用的一种拆包器，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包 如何使用LengthFieldBasedFrameDecoder 关于拆包，我们只需要关注以下3点：\n在我们的自定义协议中，长度域在整个数据包的哪个地方。用专业术语来说，就是长度域相对整个数据包的偏移量是多少，这里显然是4+1+1+1=7\n另外需要关注的就是，长度域的长度是多少，这里显然是4\n有了长度域偏移量和长度域的长度，我们就可以构造一个拆包器\n1 new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 7, 4); 拒绝非本协议连接 1 2 3 4 if (in.getInt(in.readerIndex()) != PacketCodeC.MAGIC_NUMBER) { ctx.channel().close(); return null; } 客户端和服务端的Pipeline结构 ChannelHandler 的生命周期 1 2 3 4 5 6 7 8 handlerAdded() channelRegister() channelActive() channelRead() channelReadComplete() channelInactive() channelUnregistered() handlerRemove() ChannelInitializer 的实现原理 ChannelInitializer 定义了一个抽象的 initChannel() 方法，这个抽象方法由我们自行实现。我们在服务端启动流程里的实现逻辑就是往 Pipeline 里组织我们的 Handler 链\nhandlerAdded() 方法和c hannelRegistered() 方法都会尝试调用 initChannel() 方法，initChannel() 方法使用p utIfAbsent() 方法来防止initChannel() 方法被调用多次\nchannelRegistered() 方法里还有机会再调一次 initChannel() 方法，把自定义的 Handler 都添加到 Pipeline 中去\nChannelHandler的 热插拔机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class AuthHandler extends ChannelInboundHandlerAdapter { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { if (!LoginUtils.hasLogin(ctx.channel())) { ctx.channel().close(); } else { ctx.pipeline().remove(this); super.channelRead(ctx, msg); } } @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception { if (LoginUtils.hasLogin(ctx.channel())) { System.out.println(\u0026#34;当前登陆验证完毕，无需再次验证， AuthHandler 被移除\u0026#34;); } else { System.out.println(\u0026#34;无登陆验证，强制关闭连接！\u0026#34;); } } } ","date":"2025-02-20T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/netty-%E5%8D%95%E8%81%8A%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B/cover_hu13470193518169690147.png","permalink":"https://yangzhaoxing90.github.io/p/netty-%E5%8D%95%E8%81%8A%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B/","title":"Netty 单聊实现案例"},{"content":"","date":"2025-02-18T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/log4j-%E8%BF%90%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/cover_hu247291184403147780.png","permalink":"https://yangzhaoxing90.github.io/p/log4j-%E8%BF%90%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","title":"Log4J 运用和源码解析"},{"content":" 计划日期 基金 A 利息 基金总投入额 基金 B 利息 基金 B 总投入额 周周宝利息 周周宝总投入额 利息总计 投入额总计 2025-02-10 0 0 0 0 0 0 0 0 2025-03-12 2025-04-11 2025-05-11 2025-06-10 2025-07-10 2025-08-09 2025-09-08 2025-10-08 2025-11-07 2025-12-07 2026-01-06 2026-02-10 2026-03-12 2026-04-11 2026-05-11 2026-06-10 2026-07-10 2026-08-09 2026-09-08 2026-10-08 2026-11-07 2026-12-07 2027-01-06 2027-02-10 2027-03-12 2027-04-11 2027-05-11 2027-06-10 2027-07-10 2027-08-09 2027-09-08 2027-10-08 2027-11-07 2027-12-07 2028-01-06 2028-02-10 2028-03-12 2028-04-11 2028-05-11 2028-06-10 2028-07-10 2028-08-09 2028-09-08 2028-10-08 2028-11-07 2028-12-07 2030-01-06 2030-02-10 2030-03-12 2030-04-11 2030-05-11 2030-06-10 2030-07-10 2030-08-09 2030-09-08 2030-10-08 2030-11-07 2030-12-07 2030-01-06 2030-02-10 2030-03-12 2030-04-11 2030-05-11 2030-06-10 2030-07-10 2030-08-09 2030-09-08 2030-10-08 2030-11-07 2030-12-07 ","date":"2025-02-18T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E7%90%86%E8%B4%A2%E8%AE%A1%E5%88%92/cover_hu18302932982797454197.jpg","permalink":"https://yangzhaoxing90.github.io/p/%E7%90%86%E8%B4%A2%E8%AE%A1%E5%88%92/","title":"理财计划"},{"content":"准备资料 《Java I/O》 O\u0026rsquo;Reilly\nPreface Java I/O endeavors to show you how to really use Java\u0026rsquo;s I/O classes, allowing you to quickly and easily write programs that accomplish many common tasks. Some of these include:\nReading and writing files Communicating over network connections Filtering data Interpreting a wide variety of formats for integer and floating-point numbers Passing data between threads Encrypting and decrypting data Calculating digital signatures for streams Compressing and decompressing data Writing objects to streams Copying, moving, renaming, and getting information about files and directories Letting users choose files from a GUI interface Reading and writing non-English text in a variety of character sets Formatting integer and floating-point numbers as strings Talking directly to modems and other serial port devices Talking directly to printers and other parallel port devices Organization of the Book Part I: Basic I/O Chapter I: Introducing I/O tips: For the most part I/O in Java is divided into two types: byte- and number-oriented I/O\n1.1 What Is a Stream?\nA stream is an ordered sequence of bytes of undetermined length\nThe word stream is derived from an analogy with a stream of water.\n1.1.1 Where Do Streams Come From?\nThe first source of input most programmers encounter is System.in.\nFiles are another common source of input and destination for output.\nNetwork connections provide streams too.\nJava programs themselves produce streams.\nPerhaps a little surprisingly, AWT (and Swing) components like TextArea do not produce streams.\n1.1.2 The Stream Classes\nThe two main classes are java.io.InputStream and java.io.OutputStream.\n1.2 Numeric Data\nInput streams read bytes and output streams write bytes. Readers read characters and writers write characters.\n1.2.1 Integer Data\ntype size range int 4byte -2,147,483,648 to 2,147,483,647 long 8byte -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 short 2byte -32,768 to 32,767 byte 1byte -128 to 127 1.1.2 Conversions and Casts\nint To byte\n1 2 3 4 5 6 7 int byteValue; int temp = intValue % 256; // 获取最后两个位的值 (0-255 加个符号) if (intValue \u0026lt; 0) { byteValue = temp \u0026lt; -128? 256+temp : temp; } else { byteValue = temp \u0026gt; 127? temp-256 : temp; } 1.3 Character Data\nSince computers only really understand numbers, characters are encoded by matching each character in a given script to a particular number.\n1.3.1 ASCII\nASCII, the American Standard Code for Information Interchange, is a seven-bit character set.\n1.3.2 ISO Latin-1\nISO Latin-1 suffices for most Western European languages, is an eight-bit character set that\u0026rsquo;s a strict superset of ASCII.\n1.3.3 Unicode\nUnicode is a 2-byte, 16-bit character set with 216 or 65,536 different possible characters.\nJava streams do not do a good job of reading Unicode text.\nStreams generally read a byte at a time, but each Unicode character occupies two bytes.\nThus, to read a Unicode character, you multiply the first byte read by 256, add it to the second byte read, and cast the result to a char.\n1 2 3 int b1 = in.read(); int b2 = in.read(); char c = (char) (b1*256 + b2); 1.3.4 UTF-8\nA more efficient encoding would use fewer bits for the more common characters. This is what UTF-8 does.\nJava\u0026rsquo;s .class files use UTF-8 internally to store string literals.\nData input streams and data output streams also read and write strings in UTF-8.\n1.3.5 The char Data Type\nIn Java, a char is a two-byte, unsigned integer, the only unsigned type in Java.\n1.4 Readers and Writers\n1.5 The Ubiquitous IOException\njava.util.zip (DataFormatException and ZipException)\njava.net (BindException, ConnectException, MalformedURLException, NoRouteToHostException, ProtocolException, SocketException, UnknownHostException, and UnknownServiceException).\n1.6 The Console: System.out, System.in, and System.err\n1.7 Security Checks on I/O\nChapter 2. Output Streams 2.1 The OutputStream Class\n1 2 3 4 5 6 7 java.io.OutputStream public abstract void write(int b) throws IOException public void write(byte[] data) throws IOException public void write(byte[] data, int offset, int length) throws IOException public void flush() throws IOException public void close() throws IOException 2.2 Writing Bytes to Output Streams\n1 public abstract void write(int b) throws IOException 超出的按照 b \u0026amp; 0xFF (0-255) 转换来输出\n2.3 Writing Arrays of Bytes\n1 2 3 4 5 6 public void write(byte[] data) throws IOException public void write(byte[] data, int offset, int length) throws IOException String s = \u0026#34;How are streams treating you?\u0026#34;; byte[] data = s.getBytes(); System.out.write(data); 2.4 Flushing and Closing Output Streams\nThe flush() method forces the data to be written whether or not the buffer is full:\n1 public void flush() throws IOException This should happen when the program exits or when you explicitly invoke the close() method:\n1 public void close() throws IOException 2.5 Subclassing OutputStream\nRecall that there are three overloaded variants of the write() method in OutputStream, one abstract, two concrete:\n1 2 3 4 5 6 7 public abstract void write(int b) throws IOException public void write(byte[] data) throws IOException public void write(byte[] data, int offset, int length) throws IOException public void write(byte[] data, int offset, int length) throws IOException { for (int i = offset; i \u0026lt; offset+length; i++) write(data[i]); } 2.6 A Graphical User Interface for Output Streams\npass\nChapter 3. Input Streams 3.1 The InputStream Class\nThe java.io.InputStream class is the abstract superclass for all input streams.\n1 2 3 4 5 6 7 8 9 public abstract int read() throws IOException public int read(byte[] data) throws IOException public int read(byte[] data, int offset, int length) throws IOException public long skip(long n) throws IOException public int available() throws IOException public void close() throws IOException public synchronized void mark(int readlimit) public synchronized void reset() throws IOException public boolean markSupported() 3.2 The read( ) Method\n1 public abstract int read() throws IOException This is a number between and 255\n1 2 3 4 int[] data = new int[10]; for (int i = 0; i \u0026lt; data.length; i++) { data[i] = System.in.read(); } Notice that although read() is reading a byte, it returns an int.\nIf you want to store the raw bytes instead, you can cast the int to a byte. For example:\n1 2 3 4 byte[] b = new byte[10]; for (int i = 0; i \u0026lt; b.length; i++) { b[i] = (byte) System.in.read(); } That is, a byte in the range -128 to 127 instead of to 255\n3.3 Reading Chunks of Data from a Stream\n1 2 public int read(byte[] data) throws IOException public int read(byte[] data, int offset, int length) throws IOException For example, to attempt to read 10 bytes from System.in, you could write the following code:\n1 2 3 4 5 6 try { byte[] b = new byte[10]; System.in.read(b); } catch (IOException e) { System.err.println(\u0026#34;Couldn\u0026#39;t read from System.in!\u0026#34;); } 3.4 Counting the Available Bytes\nIt\u0026rsquo;s sometimes convenient to know how many bytes are available to be read before you attempt to read them.\n1 2 3 4 5 6 7 public int available() throws IOException try { byte[] b = new byte[System.in.available()]; System.in.read(b); } catch (IOException e) {System.err.println(\u0026#34;Couldn\u0026#39;t read from System.in!\u0026#34;);} 3.5 Skipping Bytes\nThe argument to skip() is the number of bytes to skip. The return value is the number of bytes actually skipped, which may be less than bytesToSkip. -1 is returned if the end of stream is encountered.\n1 2 3 4 5 6 7 8 9 10 11 public long skip(long bytesToSkip) throws IOException try { long bytesSkipped = 0; long bytesToSkip = 80; while (bytesSkipped \u0026lt; bytesToSkip) { long n = in.skip(bytesToSkip - bytesSkipped); if (n == -1) break; bytesSkipped += n; } } catch (IOException e) {System.err.println(e);} 3.6 Closing Input Streams\n1 2 3 4 5 6 7 8 9 public void close() throws IOException try { URL u = new URL(\u0026#34;http://www.javasoft.com/\u0026#34;); InputStream in = u.openStream(); // Read from the stream... in.close(); } catch (IOException e) {System.err.println(e);} 3.7 Marking and Resetting\nIt\u0026rsquo;s often useful to be able to read a few bytes and then back up and reread them.\n1 2 3 public synchronized void mark(int readLimit) public synchronized void reset() throws IOException public boolean markSupported() The boolean markSupported() method returns true if this stream supports marking and false if it doesn\u0026rsquo;t.\nThe only two input stream classes in java.io that always support marking are BufferedInputStream (of which System.in is an instance) and ByteArrayInputStream.\n3.8 Subclassing InputStream\n3.9 An Efficient Stream Copier\n1 2 3 4 5 6 byte[] buffer = new byte[256]; while (true) { int bytesRead = in.read(buffer); if (bytesRead == -1) break; out.write(buffer, 0, bytesRead); } Part II: Data Sources Chapter 4. File Streams FileInputStream and FileOutputStream provide input and output streams that let you read and write files.\n4.1 Reading Files\n1 2 3 public FileInputStream(String fileName) throws IOException public FileInputStream(File file) throws FileNotFoundException public FileInputStream(FileDescriptor fdObj) Filenames are platform-dependent, so hardcoded file names should be avoided where possible.\nTherefore, the second two constructors are much preferred.\n1 2 3 4 5 6 7 8 9 10 11 12 13 try { FileInputStream fis = new FileInputStream(\u0026#34;README.TXT\u0026#34;); int n; while ((n = fis.available()) \u0026gt; 0) { byte[] b = new byte[n]; int result = fis.read(b); if (result == -1) break; String s = new String(b); System.out.print(s); } // End while } // End try catch (IOException e) {System.err.println(e);} System.out.println(); Java looks for files in the current working directory.\n1 public final FileDescriptor getFD() throws IOException This method returns the java.io.FileDescriptor object associated with this stream.\n1 protected void finalize() throws IOException You don\u0026rsquo;t normally need to invoke this method explicitly, but if you subclass FileInputStream (something I\u0026rsquo;ve never found a need for)\nyou must invoke super.finalize() from your subclass\u0026rsquo;s finalize() method.\nIt is possible to open multiple input streams to the same file at the same time, though it\u0026rsquo;s rarely necessary to do so.\nEach stream maintains a separate pointer to the current position in the file.\nReading from the file does not change the file in any way.\n4.2 Writing Files\nThe java.io.FileOutputStream class is a concrete subclass of java.io.OutputStream that provides output streams connected to files\n1 2 3 public FileOutputStream(String filename) throws IOException public FileOutputStream(File file) throws IOException public FileOutputStream(FileDescriptor fd) 1 public FileOutputStream(String name, boolean append) throws IOException 4.3 File Viewer, Part 1\nChapter 5. Network Streams 5.1 URLs\nThe java.net.URL class represents a Uniform Resource Locator like http://metalab.unc.edu/javafaq/.\n1 2 3 4 5 6 public URL(String u) throws MalformedURLException public URL(String protocol, String host, String file) throws MalformedURLException public URL(String protocol, String host, int port, String file) throws MalformedURLException public URL(URL context, String u) throws MalformedURLException Often this means a particular Java implementation does not have the right protocol handler installed. Thus, given a complete absolute URL\n1 2 3 4 URL u = null; try { u = new URL(\u0026#34;http://www.poly.edu/schedule/fall97/bgrad.html#cs\u0026#34;); } catch (MalformedURLException e) { } You can also construct the URL object by passing its pieces to the constructor:\n1 2 3 4 5 URL u = null; try { u = new URL(\u0026#34;http\u0026#34;, \u0026#34;www.poly.edu\u0026#34;, \u0026#34;/schedule/fall97/bgrad.html#cs\u0026#34;); } catch (MalformedURLException e) { } Once a URL object has been constructed, there are two ways to retrieve its data.\nThe openStream() method returns a raw stream of bytes from the source.\nThe getContent() method returns a Java object that represents the data.\n1 2 3 4 5 6 7 8 9 10 try { URL u = new URL(\u0026#34;http://www.amnesty.org/\u0026#34;); InputStream in = u.openStream(); int b; while ((b = in.read()) != -1) { System.out.write(b); } } catch (MalformedURLException e) {System.err.println(e);} catch (IOException e) {System.err.println(e);} 5.2 URL Connections\nURL connections are closely related to URLs, as their name implies.\nIndeed, you get a reference to a URLConnection by using the openConnection() method of a URL object\nin many ways, the URL class is only a wrapper around the URLConnection class.\nHowever, URL connections provide more control over the communication between the client and the server.\nReading Data from URL Connections\nURL connections take place in five steps:\nThe URL object is constructed.\nThe openConnection() method of the URL object creates the URLConnection object.\nThe parameters for the connection and the request properties that the client sends to the server are set up.\nThe connect() method makes the connection to the server, perhaps using a socket for a network connection or a file input stream for a local connection. The response header information is read from the server.\nData is read from the connection by using the input stream returned by getInputStream() or through a content handler with getContent(). Data can be sent to the server using the output stream provided by getOutputStream().\n1 2 3 4 5 6 7 8 9 try { URL u = new URL(\u0026#34;http://www.digitalthink.com/\u0026#34;); URLConnection uc = u.openConnection(); uc.connect(); InputStream in = uc.getInputStream(); //... } catch (IOException e) { //... Writing Data on URL Connections\nHere are the steps for writing data on a URLConnection:\nConstruct the URL object.\nCall the openConnection() method of the URL object to create the URLConnection object.\nPass true to setDoOutput() to indicate that this URLConnection will be used for output.\nIf you also want to read input from the stream, invoke setDoInput(true) to indicate that this URLConnection will be used for input.\nCreate the data you want to send, preferably as a byte array.\nCall getOutputStream() to get an output stream object. Write the byte array calculated in step 5 onto the stream.\nClose the output stream.\nCall getInputStream() to get an input stream object. Read and write it as usual.\n5.3 Sockets\nBefore data is sent across the Internet from one host to another, it is split into packets of varying but finite size called datagrams.\nFortunately, packets are invisible to the Java programmer.\nThe host\u0026rsquo;s native networking software splits data into packets on the sending end and reassembles packets on the receiving end.\nInstead, the Java programmer is presented with a higher-level abstraction called a socket.\nThe socket represents a reliable connection for the transmission of data between two hosts.\nA socket performs four fundamental operations:\nConnect to a remote machine Send data Receive data Close the connection A socket may not be connected to more than one host at a time. However, a socket may both send data to and receive data from the host to which it\u0026rsquo;s connected.\nThe java.net.Socket class is Java\u0026rsquo;s interface to a network socket and allows you to perform all four fundamental socket operations\n1 2 3 4 5 public Socket(String host, int port) throws UnknownHostException, IOException public Socket(InetAddress address, int port) throws IOException public Socket(String host, int port, InetAddress localAddr, int localPort) throws IOException public Socket(InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException Sending and receiving data across a socket is accomplished with output and input streams. These are the methods to get both streams for the socket:\n1 2 public InputStream getInputStream() throws IOException public OutputStream getOutputStream() throws IOException There\u0026rsquo;s also a method to close a socket:\n1 public synchronized void close() throws IOException 5.4 Server Sockets\nThere are two ends to each connection: the client, which initiates the connection, and the server, which responds to the connection.\nNo more than one server socket can listen to a particular port at one time.\nTherefore, since a server may need to handle many connections at once, server programs tend to be heavily multithreaded.\nIncoming connections are stored in a queue until the server can accept them.\nOn most systems, the default queue length is between 5 and 50.\nOnce the queue fills up, further incoming connections are refused until space in the queue opens up.\nThe java.net.ServerSocket class represents a server socket.\n1 2 3 public ServerSocket(int port) throws IOException public ServerSocket(int port, int backlog) throws IOException public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException Normally, you specify only the port you want to listen on:\n1 2 3 4 try { ServerSocket ss = new ServerSocket(80); } catch (IOException e) {System.err.println(e);} 0 is a special port number.\nIt tells Java to pick an available port.\nYou can then find out what port it\u0026rsquo;s picked with the getLocalPort() method:\n1 public int getLocalPort() Once you have a ServerSocket, you need to wait for incoming connections.\nYou do this by calling the accept() method, which blocks until a connection attempt occurs and then returns a Socket that you can use to communicate with the client.\nThe close() method terminates the ServerSocket.\n1 2 public Socket accept() throws IOException public void close() throws IOException Instead, accept() returns a Socket object: you call the Socket\u0026rsquo;s getInputStream() or getOutputStream() method.\nFor example:\n1 2 3 4 5 6 7 8 try { ServerSocket ss = new ServerSocket(2345); Socket s = ss.accept(); OutputStream out = s.getOutputStream(); // Send data to the client. s.close(); } catch (IOException e) {System.err.println(e);} Notice in this example, I closed the Socket s, not the ServerSocket ss.\nss is still bound to port 2345.\nYou get a new socket for each connection and reuse the server socket.\nFor example, the next code fragment repeatedly accepts connections:\n1 2 3 4 5 6 7 8 9 try { ServerSocket ss = new ServerSocket(2345); while (true) { Socket s = ss.accept(); OutputStream out = s.getOutputStream(); // send data to the client s.close(); } } catch (IOException e) {System.err.println(e);} 5.5 URLViewer\npass\nPart III: Filter Streams Chapter 6. Filter Streams Filter streams are used for encryption, compression, translation, buffering, and much more.\n6.1 The Filter Stream Classes\njava.io.FilterInputStream and java.io.FilterOutputStream are concrete superclasses for input and output stream subclasses that somehow modify or manipulate data of an underlying stream\nEach of these classes has a single protected constructor that specifies the underlying stream from which the filter stream reads or writes data:\n1 2 protected FilterInputStream(InputStream in) protected FilterOutputStream(OutputStream out) Since the constructors are protected, filter streams may only be created by subclasses.\nEach subclass implements a particular filtering operation.\n6.2 The Filter Stream Subclasses\nThe BufferedInputStream and BufferedOutputStream classes buffer reads and writes by first putting data into a buffer (an internal array of bytes).\nThe java.io.PrintStream class, which System.out and System.err are instances of, allows very simple printing of primitive values, objects, and string literals.\nThe PushbackInputStream class has a one-byte pushback buffer so a program can \u0026ldquo;unread\u0026rdquo; the last character read.\nThe DataInputStream and DataOutputStream classes read and write primitive Java data types and strings in a machine-independent way.\nThe ObjectInputStream and ObjectOutputStream classes extend DataInputStream and DataOutputStream with methods to read and write arbitrary Java objects as well as primitive data types.\nThe java.util.zip package also includes several filter stream classes.\nThe java.util.security package contains the DigestInputStream and DigestOutputStream filter streams, these calculate message digests of the data that passes through them.\nInstalling the Java Cryptography Extension (JCE) adds two more filter streams to this package, CipherInputStream and CipherOutputStream , which can encrypt or decrypt data using a variety of algorithms.\n6.3 Buffered Streams\nThere are two BufferedInputStream constructors and two BufferedOutputStream constructors:\n1 2 3 4 public BufferedInputStream(InputStream in) public BufferedInputStream(InputStream in, int size) public BufferedOutputStream(OutputStream out) public BufferedOutputStream(OutputStream out, int size) For example:\n1 2 URL u = new URL(\u0026#34;http://java.developer.com\u0026#34;); BufferedInputStream bis = new BufferedInputStream(u.openStream(), 256); BufferedInputStream Details\n1 2 3 4 5 protected byte[] buf // the buffer itself is a byte array called buf protected int count // the number of bytes in the buffer is an int named count protected int pos // the index of the next byte that will be returned by read() is an int called pos protected int markpos // the mark, if any, is an int called markpos protected int marklimit // the read-ahead limit before the mark is invalidated is an int called marklimit BufferedInputStream only overrides methods from InputStream.\nIt does not declare any new methods of its own. Marking and resetting are supported.\nBufferedOutputStream Details\n1 2 protected byte buf[] // stores the buffer in a protected byte array named buf protected int pos // the index of the next place in the array where a byte will be stored in an int field named pos BufferedOutputStream only overrides three methods from OutputStream.\nIt does not declare any new methods.\n6.4 PushbackInputStream\nThe java.io.PushbackInputStream class provides a pushback buffer so a program can \u0026ldquo;unread\u0026rdquo; the last several bytes read.\n1 2 3 public void unread(int b) throws IOException public void unread(byte[] data, int offset, int length) throws IOException public void unread(byte[] data) throws IOException However, you can change the default buffer size with the second constructor:\n1 2 public PushbackInputStream(InputStream in) public PushbackInputStream(InputStream in, int size) 6.5 Print Streams\npass\n6.6 Multitarget Output Streams\npass\n6.7 File Viewer, Part 2\npass\nChapter 7. Data Streams Data streams read and write strings, integers, floating-point numbers, and other data that\u0026rsquo;s commonly presented at a higher level than mere bytes.\n7.1 The Data Stream Classes\n1 public class DataInputStream extends FilterInputStream implements DataInput 1 public class DataOutputStream extends FilterOutputStream implements DataOutput The DataInput and DataOutput Interfaces\nThe java.io.DataInput interface declares 15 methods that read various kinds of data:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public abstract boolean readBoolean() throws IOException public abstract byte readByte() throws IOException public abstract int readUnsignedByte() throws IOException public abstract short readShort() throws IOException public abstract int readUnsignedShort() throws IOException public abstract char readChar() throws IOException public abstract int readInt() throws IOException public abstract long readLong() throws IOException public abstract float readFloat() throws IOException public abstract double readDouble() throws IOException public abstract String readLine() throws IOException public abstract String readUTF() throws IOException public void readFully(byte[] data) throws IOException public void readFully(byte[] data, int offset, int length) throws IOException public int skipBytes(int n) throws IOException the java.io.DataOutput interface declares 14 methods, mostly complementary to those in DataInput:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract void write(int b) throws IOException public abstract void write(byte[] data) throws IOException public abstract void write(byte[] data, int offset, int length) throws IOException public abstract void writeBoolean(boolean v) throws IOException public abstract void writeByte(int b) throws IOException public abstract void writeShort(int s) throws IOException public abstract void writeChar(int c) throws IOException public abstract void writeInt(int i) throws IOException public abstract void writeLong(long l) throws IOException public abstract void writeFloat(float f) throws IOException public abstract void writeDouble(double d) throws IOException public abstract void writeBytes(String s) throws IOException public abstract void writeChars(String s) throws IOException public abstract void writeUTF(String s) throws IOException Constructors\n1 2 public DataInputStream(InputStream in) public DataOutputStream(OutputStream out) 7.2 Reading and Writing Integers\npass\n7.3 Reading and Writing Floating-Point Numbers\npass\n7.4 Reading and Writing Booleans\npass\n7.5 Reading Byte Arrays\npass\n7.6 Reading and Writing Text\npass\n7.7 Miscellaneous Methods\npass\n7.8 Reading and Writing Little-Endian Numbers\npass\n7.9 Thread Safety\npass\n7.10 File Viewer, Part 3\npass\nChapter 8. Streams in Memory 8.1 Sequence Input Streams 1 2 public SequenceInputStream(Enumeration e) public SequenceInputStream(InputStream in1, InputStream in2) For example, to read the home pages of both JavaSoft and AltaVista, you might do this:\n1 2 3 4 5 6 7 try { URL u1 = new URL(\u0026#34;http://java.sun.com/\u0026#34;); URL u2 = new URL(\u0026#34;http://www.altavista.com\u0026#34;); SequenceInputStream sin = new SequenceInputStream(u1.openStream(), u2.openStream()); } catch (IOException e) { //... 8.2 Byte Array Streams Byte array input and output streams are commonly used when sending and receiving UDP data over the Internet.\n1 2 public ByteArrayInputStream(byte[] buffer) public ByteArrayInputStream(byte[] buffer, int offset, int length) 1 2 public ByteArrayOutputStream() public ByteArrayOutputStream(int size) 8.3 Communicating Between Threads with Piped Streams The java.io.PipedInputStream class and java.io.PipedOutputStream class provide a convenient means to move streaming data from one thread to another.\n1 2 public PipedInputStream() public PipedInputStream(PipedOutputStream source) throws IOException 1 2 public PipedOutputStream(PipedInputStream sink) throws IOException public PipedOutputStream() The piped input stream also has four protected fields and one protected method that are used to implement the piping:\n1 2 3 4 5 protected static final int PIPE_SIZE protected byte[] buffer protected int in protected int out protected synchronized void receive(int b) throws IOException Chapter 9. Compressing Streams 9.1 Inflaters and Deflaters\nThe java.util.zip.Deflater and java.util.zip.Inflater classes provide compression and decompression services for all other classes.\nThere are nine steps to deflating data with the Deflater class:\nConstruct a Deflater object. Choose the strategy (optional). Set the compression level (optional). Preset the dictionary (optional). Set the input. Deflate the data repeatedly until needsInput() returns true. If more input is available, go back to step 5 to provide additional input data. Otherwise, go to step 8. Finish the data. If there are more streams to be deflated, reset the deflater. Construct a Deflater object\n1 2 3 public Deflater(int level, boolean useGzip) public Deflater(int level) public Deflater() Choose a strategy\n1 2 3 4 5 public static final int DEFAULT_STRATEGY = 0; public static final int FILTERED = 1; public static final int HUFFMAN_ONLY = 2; public synchronized void setStrategy(int strategy) Set the compression level\n1 public synchronized void setLevel(int Level) Set the dictionary\n1 public void setDictionary(byte[] data) Set the input\n1 2 public void setInput(byte[] input) public synchronized void setInput(byte[] input, int offset, int length) Deflate the data repeatedly until needsInput( ) returns true\n1 2 3 public int deflate(byte[] output) public native synchronized int deflate(byte[] output, int offset, int length) Finish the deflation\n1 public synchronized void finish() Reset the deflater and start over\n1 public native synchronized void reset() Chapter 10. Cryptographic Streams pass\nPart IV: Advanced and Miscellaneous Topics Chapter 11. Object Serialization 11.1 Reading and Writing Objects\nObject serialization saves an object\u0026rsquo;s state in a sequence of bytes so that the object can be reconstituted from those bytes at a later time.\nThe customized beans are stored in a .ser file, which is often placed inside a JAR archive.\n11.2 Object Streams\nObjects are serialized by object output streams. They are deserialized by object input streams.\nThese are instances of java.io.ObjectOutputStream and java.io.ObjectInputStream\nThe ObjectOutput interface is a subinterface of java.io.DataOutput that declares the basic methods used to write objects and data.\nThe ObjectInput interface is a subinterface of java.io.DataInput that declares the basic methods used to read objects and data.\njava.io.ObjectStreamConstants is an unimportant interface that merely declares mnemonic constants for \u0026ldquo;magic numbers\u0026rdquo; used in the object serialization.\n11.3 How Object Serialization Works\n","date":"2025-02-17T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/java-i/o/cover_hu12813135243859829902.png","permalink":"https://yangzhaoxing90.github.io/p/java-i/o/","title":"Java I/O"},{"content":"参考资料 《深入理解Java虚拟机：JVM高级特性与最佳实践》 《Java并发实现原理：JDK源码剖析》 《The Java® Language Specification》\nJDNI 官方文档 https://docs.oracle.com/javase/jndi/tutorial/?spm=5176.28103460.0.0.3e185d27mU1E2i\nGetting Started Naming Concepts:\nNaming Service:\nwhich names are associated with objects and objects are found based on their names. Naming convention:\nThe naming system determines the syntax that the name must follow. This syntax is sometimes called the naming system\u0026rsquo;s naming convention. Bindings:\nThe association of a name with an object is called a binding. References (Addresses):\nA reference is information about how to access an object. Context:\nA context is a set of name-to-object bindings. Naming System:\nA naming system is a connected set of contexts of the same type (they have the same naming convention) and provides a common set of operations. Namespace:\nA namespace is the set of names in a naming system. Directory Concepts\nDirectory Service:\nA directory service associates names with objects and also allows such objects to have attributes. A directory service is a service that provides operations for creating, adding, removing, and modifying the attributes associated with objects in a directory. Attributes:\nA directory object can have attributes. An attribute has an attribute identifier and a set of attribute values. Search Filter:\nWhen you search, you can supply not a name but a query consisting of a logical expression in which you specify the attributes that the object or objects must have. The query is called a search filter. JNDI Overview package: javax.naming (Context,Names,Bindings,References), javax.naming.directory (DirContext, Searchxx)\nArchitecture\nThe Examples how to look up an object\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; Hashtable env = new Hashtable(); env.put(Context.INITIAL_CONTEXT_FACTORY, \u0026#34;com.sun.jndi.fscontext.RefFSContextFactory\u0026#34;); Context ctx = new InitialContext(env); try { // Create the initial context Context ctx = new InitialContext(env); // Look up an object Object obj = ctx.lookup(name); // Print it System.out.println(name + \u0026#34; is bound to: \u0026#34; + obj); } catch (NamingException e) { System.err.println(\u0026#34;Problem looking up \u0026#34; + name + \u0026#34;: \u0026#34; + e); } how to read an attribute from a directory service\n安装 LDAP https://www.openldap.org/software/download/ 1 2 3 ./configure make depend make 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Hashtable env = new Hashtable(); env.put(Context.INITIAL_CONTEXT_FACTORY, \u0026#34;com.sun.jndi.ldap.LdapCtxFactory\u0026#34;); env.put(Context.PROVIDER_URL, \u0026#34;ldap://localhost:389/o=JNDITutorial\u0026#34;); try { // Create the initial directory context DirContext ctx = new InitialDirContext(env); // Ask for all attributes of the object Attributes attrs = ctx.getAttributes(\u0026#34;cn=Ted Geisel, ou=People\u0026#34;); // Find the surname attribute (\u0026#34;sn\u0026#34;) and print it System.out.println(\u0026#34;sn: \u0026#34; + attrs.get(\u0026#34;sn\u0026#34;).get()); } catch (NamingException e) { System.err.println(\u0026#34;Problem getting attribute:\u0026#34; + e); } 总结: jdni 就是类似 jdbc 的东西，用于连接 ldap，dns 等服务用的\nJava IO 《Java I/O》 O\u0026rsquo;Reilly\nJava NIO 《Java NIO》 Ron Hitchens\nhttps://jcp.org/en/jsr/detail?id=51 JCP51 包含了对高速、可伸缩 I/O 特性的详细描述\n","date":"2025-02-14T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/jdk-%E5%AD%A6%E4%B9%A0/cover_hu7535847215873482167.png","permalink":"https://yangzhaoxing90.github.io/p/jdk-%E5%AD%A6%E4%B9%A0/","title":"JDK 学习"},{"content":"官方文档 Spring 官方文档 https://docs.spring.io/spring-framework/docs/5.3.39/reference/html/\nSpring 中文文档 https://springdoc.cn/spring/\nEnvironment Abstraction Two Key Aspects:\nprofiles (logical group of bean definitions to be registered with the container only if the given profile is active) properties Bean Definition Profiles\n@Profile:\nuse to Mark class use to Mark annotation use to Mark method Profile expression:\n!: A logical “not” of the profile \u0026amp;: A logical “and” of the profiles |: A logical “or” of the profiles XML Bean Definition Profiles\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:jdbc=\u0026#34;http://www.springframework.org/schema/jdbc\u0026#34; xmlns:jee=\u0026#34;http://www.springframework.org/schema/jee\u0026#34; xsi:schemaLocation=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!-- other bean definitions --\u0026gt; \u0026lt;beans profile=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;jdbc:embedded-database id=\u0026#34;dataSource\u0026#34;\u0026gt; \u0026lt;jdbc:script location=\u0026#34;classpath:com/bank/config/sql/schema.sql\u0026#34;/\u0026gt; \u0026lt;jdbc:script location=\u0026#34;classpath:com/bank/config/sql/test-data.sql\u0026#34;/\u0026gt; \u0026lt;/jdbc:embedded-database\u0026gt; \u0026lt;/beans\u0026gt; \u0026lt;beans profile=\u0026#34;production\u0026#34;\u0026gt; \u0026lt;jee:jndi-lookup id=\u0026#34;dataSource\u0026#34; jndi-name=\u0026#34;java:comp/env/jdbc/datasource\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; \u0026lt;/beans\u0026gt; Activating a Profile\n1 2 3 4 AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); ctx.getEnvironment().setActiveProfiles(\u0026#34;development\u0026#34;); ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class); ctx.refresh(); The default profile represents the profile that is enabled by default.\n1 @Profile(\u0026#34;default\u0026#34;) PropertySource Abstraction 1 2 3 4 ApplicationContext ctx = new GenericApplicationContext(); Environment env = ctx.getEnvironment(); boolean containsMyProperty = env.containsProperty(\u0026#34;my-property\u0026#34;); System.out.println(\u0026#34;Does my environment contain the \u0026#39;my-property\u0026#39; property? \u0026#34; + containsMyProperty); ","date":"2025-02-14T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/spring-framework/cover_hu593023993242551048.png","permalink":"https://yangzhaoxing90.github.io/p/spring-framework/","title":"Spring Framework"},{"content":"Spring 的整体架构 Core Container (核心容器):\nBeans (IOC相关组件) Core (核心工具类) Context (扩展) EL (表达式，用于运行时操作和查询对象) Data Access (数据访问)：\nJDBC (数据库访问) ORM (对象关系映射 API) OXM (Object/XML 映射) JMS (制造和消费消息) Transaction (编程和声明式事务) Web (网络):\nWeb (Web集成特性) Servlet (Servlet MVC实现) Struts (Struts MVC实现) Portlet (Portlet MVC实现) AOP (切面编程):\nAspects (AspectJ) Instrumentation (class instrumentation, classloader 实现) Test (测试):\nJUnit 和 TestNG 等 Spring 源码下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 \u0026lt;properties\u0026gt; ... \u0026lt;spring.version\u0026gt;5.3.39\u0026lt;/spring.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aspects\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context-support\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-instrument\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-instrument-tomcat --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-instrument-tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3.30.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jms\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-orm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-websocket\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 容器的基本实现 将一个简单的 MyTestBean注册到容器成 POJO\n1 2 3 4 5 6 7 8 9 10 11 12 public class MyTestBean { private String testStr = \u0026#34;testStr\u0026#34;; public String getTestStr() { return testStr; } public void setTestStr(String testStr) { this.testStr = testStr; } } 1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;myTestBean\u0026#34; class=\u0026#34;com.xqls.bean.MyTestBean\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 1 2 3 4 5 6 7 8 9 public class BeanFactoryTest { @Test public void testSimpleLoad() { BeanFactory bf = new XmlBeanFactory(new ClassPathResource(\u0026#34;config.xml\u0026#34;)); MyTestBean bean = (MyTestBean) bf.getBean(\u0026#34;myTestBean\u0026#34;); assertEquals(\u0026#34;testStr\u0026#34;, bean.getTestStr()); } } 总体流程 实现流程:\n文件 xml 路径 -\u0026gt; 文件封装成 Resource -\u0026gt; Bean 注册 -\u0026gt; Bean 实例化 -\u0026gt; 调用实例化的实例 流程相关组件:\nXmlBeanFactory (读取 xml 资源， 实现了 Bean 的加载和注册) ClassPathResource (读取 classpath 下的资源) DefaultListableBeanFacotry (XmlBeanFactory 继承自它， 提供了 Bean 加载和注册的默认实现) XmlBeanDefinitionReader (XmlBeanFactory 使用它读取 xml 资源的配置) Bean 注册 (加载) 流程 实现流程:\nResource -\u0026gt; 进行编码封装 -\u0026gt; 获取输入流 -\u0026gt; 输入流封装成 InputSource （准备用 SAX 的方式解析 XML）-\u0026gt; 获取对 XML 文件的验证模式 -\u0026gt; 加载 XML 文件，得到对应的 Document -\u0026gt; 根据返回的 Document 注册 Bean 信息 流程相关组件:\nEncodedResource (资源进行编码封装，调用 getReader 方法时会使用具体编码构造字符流) 获取 XML 文件验证模式流程\nDTD 和 XSD 的区别:\nDTD (文档类型定义，XML约束语言，文档包含元素的定义规则、元素间关系的定义规则、元素可使用的属性、可使用的实体或符号规则)\n1 \u0026lt;!DOCTYPE beans PUBLIC \u0026#34;-//Spring//DTD BEAN 2.0 //EN\u0026#34; \u0026#34;http://www.Springframework.org/dtd/Spring-beans-2.0.dtd\u0026#34;\u0026gt; XML Schema (XSD,描述了XML文档结构)\n1 \u0026lt;xsi:...\u0026gt; 实现流程:\n是否为自动获取验证模式 -\u0026gt; 否就直接返回, 是根据 Resource 读取 xml 进行是否包含 DOCTYPE 的判断 -\u0026gt; 包含就是 DTD 否则就是 XSD 获取 Document\n流程相关组件:\nDefaultDocumentLoader (Document 加载器) DocumentBuilderFactory (定义了一个工厂 API，使应用程序能够获得一个从 XML 文档生成 DOM 对象树的解析器, 使用 newDocumentBuilder 获取 DocumentBuilder) DocumentBuilder (定义了从 XML 文档获取 DOM Document 实例的API， 利用 parse 方法获取 Document) 解析并注册 Bean 实现流程:\n创建 BeanDefinitionDocumentReader -\u0026gt; 进行 xml 和 bean 定义的处理 -\u0026gt; profile 处理 -\u0026gt; 流程相关组件:\n- DefaultBeanDefinitionDocumentReader (它根据“spring-beans”DTD和XSD格式（Spring的默认XML bean定义格式）读取bean定义) - profile处理\n1 2 3 4 5 6 7 8 \u0026lt;beans profile=\u0026#34;dev\u0026#34;\u0026gt; ... \u0026lt;/beans\u0026gt; \u0026lt;beans profile=\u0026#34;production\u0026#34;\u0026gt; ... \u0026lt;/beans\u0026gt; 1 2 3 4 \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;Spring.profiles.active\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;dev\u0026lt;/param-value\u0026gt; \u0026lt;/conetxt-param\u0026gt; ","date":"2025-02-14T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/spring-%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/cover_hu13580391740112720198.png","permalink":"https://yangzhaoxing90.github.io/p/spring-%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","title":"Spring 源码深度解析"},{"content":"Spring 概念通识 Spring 抽象 类型 说明 Resource 接口 文件或类路径资源抽象 Bean 概念 实体、POJO InputSource 接口 XML 实体的单一输入源 Document 接口 整个 HTML 或 XML 文档 DocumentLoader 接口 用于加载 XML 文档的策略接口 BeanDefinitionDocumentReader 接口 用于实际解析 DOM 文档 Resource 包路径：org.springframework.core.io\n用于资源描述符的接口，该接口对实际类型的底层资源（如文件或类路径资源）进行了抽象\n如果资源以物理形式存在，则可以为其打开一个 InputStream，但对于某些资源，仅能返回一个 URL 或 File 句柄\n这种设计允许处理不同类型的资源时使用统一的接口，而无需关心资源的具体类型是文件、网络资源还是其他形式\n这增加了代码的灵活性和可复用性。在具体的实现中，根据资源的不同类型，可能支持不同的操作\n重要的方法：\ngetInputStream() getURL() getURI() getFile() 相关实现类或接口:\nWritableResource ContextResource UrlResource FileUrlResource FileSystemResource ClassPathResource ByteArrayResource InputStreamResource 总结：\n其实就是读取资源，然后拿到 InputStream 或者 URL 或者 URI 等其他文件性质的属性 InputSource XML 实体的单一输入源\n此模块（包括源代码和文档）位于公共域中，且不提供任何担保，更多信息，请参见 http://www.saxproject.org\n此类允许 SAX 应用程序将有关输入源的信息封装在一个对象中，该对象可能包含一个公共标识符、一个系统标识符、一个字节流（可能带有指定的编码）和/或一个字符流\n应用程序可以通过两个途径向解析器传递输入源：作为 Parser.parse 方法的参数，或者作为 EntityResolver.resolveEntity 方法的返回值\nSAX 解析器将使用 InputSource 对象来确定如何读取 XML 输入\n如果有可用的字符流，解析器将直接读取该流，并忽略在该流中找到的任何文本编码声明\n如果没有字符流但有字节流，解析器将使用该字节流，并采用 InputSource 中指定的编码，或者（如果没有指定编码）使用类似于 XML 规范中的一种算法自动检测字符编码。如果既没有字符流也没有字节流，解析器将尝试打开一个 URI 连接，以访问由系统标识符识别的资源\nInputSource 对象属于应用程序：SAX 解析器绝不应以任何方式修改它（如有必要，解析器可能会修改其副本）\n然而，对于字节流和字符流的标准处理是在解析结束时关闭它们作为清理工作的一部分，因此应用程序不应在这些流被交给解析器之后试图重用它们\n这个设计确保了灵活性和对不同输入类型的兼容性，同时明确了应用与解析器之间的责任划分\nDocument Document 接口代表整个 HTML 或 XML 文档\n概念上，它是文档树的根节点，并提供了访问文档数据的主要途径\n由于元素、文本节点、注释、处理指令等不能独立于 Document 存在，Document 接口还包含了创建这些对象所需的工厂方法\n创建的 Node 对象具有一个 ownerDocument 属性，该属性将它们与创建它们时所在的 Document 关联起来\n另请参阅文档对象模型（DOM）3级核心规范\n这个解释说明了 Document 接口在文档结构中的核心地位及其功能，包括它如何作为其他节点类型的基础，并确保所有节点都关联到创建它们的文档实例\n这有助于理解 DOM 的层级结构和节点之间的关系\nBeanDefinitionDocumentReader 用于解析包含 Spring bean 定义的 XML 文档的 SPI（服务提供者接口）\n由 XmlBeanDefinitionReader 使用，用于实际解析 DOM 文档\n每个要解析的文档都会实例化一个此类的对象：\n其实现可以在执行 registerBeanDefinitions 方法期间在实例变量中保存状态——例如，为文档中的所有 bean 定义设定的全局设置\n","date":"2025-02-14T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/spring-%E7%9B%B8%E5%85%B3%E6%8A%BD%E8%B1%A1/cover_hu6340837035305611040.jpg","permalink":"https://yangzhaoxing90.github.io/p/spring-%E7%9B%B8%E5%85%B3%E6%8A%BD%E8%B1%A1/","title":"Spring 相关抽象"},{"content":"What is Maven? The result is a tool that can now be used for building and managing any Java-based project.\nMaven\u0026rsquo;s Objectives\nMaking the build process easy Providing a uniform build system Providing quality project information Encouraging better development practices Maven in 5 Minutes installation 1 mvn --version Creating a Project\n1 mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.5 -DinteractiveMode=false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 my-app |-- pom.xml `-- src |-- main | `-- java | `-- com | `-- mycompany | `-- app | `-- App.java `-- test `-- java `-- com `-- mycompany `-- app `-- AppTest.java The src/main/java directory contains the project source code.\nThe src/test/java directory contains the test source.\nThe pom.xml file is the project\u0026rsquo;s Project Object Model, or POM.\nThis is a Maven convention and to learn more about it you can read our Introduction to the Standard Directory Layout.\nThe POM\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.mycompany.app\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;my-app\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;my-app\u0026lt;/name\u0026gt; \u0026lt;!-- FIXME change it to the project\u0026#39;s website --\u0026gt; \u0026lt;url\u0026gt;http://www.example.com\u0026lt;/url\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;maven.compiler.release\u0026gt;17\u0026lt;/maven.compiler.release\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-bom\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.11.0\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-api\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Optionally: parameterized tests support --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-params\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;pluginManagement\u0026gt;\u0026lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --\u0026gt; ... lots of helpful plugins \u0026lt;/pluginManagement\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; label meaning project This is the top-level element in all Maven pom.xml files. modelVersion This element indicates what version of the object model this POM is using. The version of the model itself changes very infrequently but it is mandatory in order to ensure stability of use if and when the Maven developers deem it necessary to change the model. groupId This element indicates the unique identifier of the organization or group that created the project. The groupId is one of the key identifiers of a project and is typically based on the fully qualified domain name of your organization. artifactId This element indicates the unique base name of the primary artifact being generated by this project. The primary artifact for a project is typically a JAR file. Secondary artifacts like source bundles also use the artifactId as part of their final name. version This element indicates the version of the artifact generated by the project. Maven goes a long way to help you with version management and you will often see the SNAPSHOT designator in a version, which indicates that a project is in a state of development. name This element indicates the display name used for the project. This is often used in Maven\u0026rsquo;s generated documentation. url This element indicates where the project\u0026rsquo;s site can be found. This is often used in Maven\u0026rsquo;s generated documentation. properties This element contains value placeholders accessible anywhere within a POM. dependencies This element\u0026rsquo;s children list dependencies. The cornerstone of the POM. build This element handles things like declaring your project\u0026rsquo;s directory structure and managing plugins. For a complete reference of what elements are available for use in the POM please refer to our POM Reference.\nMaven in 30 Minutes What is Maven?\nMaven is essentially a project management and comprehension tool and as such provides a way to help with managing:\nBuilds Documentation Reporting Dependencies SCMs Releases Distribution How do I compile my application sources?\n1 mvn compile How do I compile my test sources and run my unit tests?\n1 2 mvn test mvn test-compile How do I create a JAR and install it in my local repository?\n1 2 3 4 mvn package mvn install mvn site mvn clean What is a SNAPSHOT version?\n1 2 3 4 5 6 7 8 \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; ... \u0026lt;groupId\u0026gt;...\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;my-app\u0026lt;/artifactId\u0026gt; ... \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;Maven Quick Start Archetype\u0026lt;/name\u0026gt; ... The SNAPSHOT value refers to the \u0026rsquo;latest\u0026rsquo; code along a development branch, and provides no guarantee the code is stable or unchanging.\nHow do I use plugins?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ... \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.5\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.5\u0026lt;/target\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; ... How do I add resources to my JAR?\nYou see below in our example we have added the directory ${project.basedir}/src/main/resources into which we place any resources we wish to package in our JAR. The simple rule employed by Maven is this: any directories or files placed within the ${project.basedir}/src/main/resources directory are packaged in your JAR with the exact same structure starting at the base of the JAR.\nHow do I filter resource files?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;build\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;build\u0026gt; \u0026lt;filters\u0026gt; \u0026lt;filter\u0026gt;src/main/filters/filter.properties\u0026lt;/filter\u0026gt; \u0026lt;/filters\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; How do I use external dependencies?\nIntroduction to Dependency Mechanism\nHow do I deploy my jar in my remote repository?\nFor deploying jars to an external repository, you have to configure the repository url in the pom.xml and the authentication information for connecting to the repository in the settings.xml.\nHow do I create documentation?\n1 2 3 4 5 mvn archetype:generate \\ -DarchetypeGroupId=org.apache.maven.archetypes \\ -DarchetypeArtifactId=maven-archetype-site \\ -DgroupId=com.mycompany.app \\ -DartifactId=my-app-site How do I build other types of projects?\n1 2 3 4 5 mvn archetype:generate \\ -DarchetypeGroupId=org.apache.maven.archetypes \\ -DarchetypeArtifactId=maven-archetype-webapp \\ -DgroupId=com.mycompany.app \\ -DartifactId=my-webapp How do I build more than one project at once?\npass\nPOM Reference https://maven.apache.org/pom.html\nSettings Reference https://maven.apache.org/settings.html\nRunning Apache Maven 1 2 3 mvn [options] [\u0026lt;goal(s)\u0026gt;] [\u0026lt;phase(s)\u0026gt;] mvn -h The built-in lifecycles and their most used phases, in order, are:\nclean - clean default - validate, compile, test, package, verify, install, deploy site - site, site-deploy Maven Plugins Maven is - at its heart - a plugin execution framework. all work is done by plugins.\nBuild plugins will be executed during the build and they should be configured in the element from the POM. Reporting plugins will be executed during the site generation and they should be configured in the element from the POM. https://maven.apache.org/plugins/index.html\n","date":"2025-02-11T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/maven/cover_hu5078302584087154681.png","permalink":"https://yangzhaoxing90.github.io/p/maven/","title":"Maven"},{"content":"The Basics Introduction to the Apache Shiro Java Security Framework Here are some things that you can do with Apache Shiro:\nAuthenticate a user to verify their identity Perform access control for a user, such as: Determine if a user is assigned a certain security role or not Determine if a user is permitted to do something or not Use a Session API in any environment, even without web or EJB containers. React to events during authentication, access control, or during a session’s lifetime. Aggregate 1 or more data sources of user security data and present this all as a single composite user \u0026lsquo;view\u0026rsquo;. Enable Single Sign On (SSO) functionality Enable \u0026lsquo;Remember Me\u0026rsquo; services for user association without login \u0026hellip; Apache Shiro Features:\nAuthentication: Sometimes referred to as \u0026rsquo;login\u0026rsquo;, this is the act of proving a user is who they say they are. Authorization: The process of access control, i.e. determining \u0026lsquo;who\u0026rsquo; has access to \u0026lsquo;what\u0026rsquo;. Session Management: Managing user-specific sessions, even in non-web or EJB applications. Cryptography: Keeping data secure using cryptographic algorithms while still being easy to use. Architecture Subject: basically anything that is currently interacting with the software SecurityManager: When you interact with a Subject, those interactions translate to subject-specific interactions with the SecurityManager Realms: Realms act as the ‘bridge’ or ‘connector’ between Shiro and your application’s security data 10 Minute Tutorial on Apache Shiro 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // The easiest way to create a Shiro SecurityManager with configured // realms, users, roles and permissions is to use the simple INI config. // We\u0026#39;ll do that by using a factory that can ingest a .ini file and // return a SecurityManager instance: // Use the shiro.ini file at the root of the classpath // (file: and url: prefixes load from files and urls respectively): SecurityManager securityManager = new BasicIniEnvironment(\u0026#34;classpath:shiro.ini\u0026#34;).getSecurityManager(); // for this simple example quickstart, make the SecurityManager // accessible as a JVM singleton. Most applications wouldn\u0026#39;t do this // and instead rely on their container configuration or web.xml for // webapps. That is outside the scope of this simple quickstart, so // we\u0026#39;ll just do the bare minimum, so you can continue to get a feel // for things. SecurityUtils.setSecurityManager(securityManager); // Now that a simple Shiro environment is set up, let\u0026#39;s see what you can do: // get the currently executing user: Subject currentUser = SecurityUtils.getSubject(); // Do some stuff with a Session (no need for a web or EJB container!!!) Session session = currentUser.getSession(); session.setAttribute(\u0026#34;someKey\u0026#34;, \u0026#34;aValue\u0026#34;); String value = (String) session.getAttribute(\u0026#34;someKey\u0026#34;); if (value.equals(\u0026#34;aValue\u0026#34;)) { log.info(\u0026#34;Retrieved the correct value! [\u0026#34; + value + \u0026#34;]\u0026#34;); } // let\u0026#39;s login the current user so we can check against roles and permissions: if (!currentUser.isAuthenticated()) { UsernamePasswordToken token = new UsernamePasswordToken(\u0026#34;lonestarr\u0026#34;, \u0026#34;vespa\u0026#34;); token.setRememberMe(true); try { currentUser.login(token); } catch (UnknownAccountException uae) { log.info(\u0026#34;There is no user with username of \u0026#34; + token.getPrincipal()); } catch (IncorrectCredentialsException ice) { log.info(\u0026#34;Password for account \u0026#34; + token.getPrincipal() + \u0026#34; was incorrect!\u0026#34;); } catch (LockedAccountException lae) { log.info(\u0026#34;The account for username \u0026#34; + token.getPrincipal() + \u0026#34; is locked. \u0026#34; + \u0026#34;Please contact your administrator to unlock it.\u0026#34;); } // ... catch more exceptions here (maybe custom ones specific to your application? catch (AuthenticationException ae) { //unexpected condition? error? } } //say who they are: //print their identifying principal (in this case, a username): log.info(\u0026#34;User [\u0026#34; + currentUser.getPrincipal() + \u0026#34;] logged in successfully.\u0026#34;); //test a role: if (currentUser.hasRole(\u0026#34;schwartz\u0026#34;)) { log.info(\u0026#34;May the Schwartz be with you!\u0026#34;); } else { log.info(\u0026#34;Hello, mere mortal.\u0026#34;); } //test a typed permission (not instance-level) if (currentUser.isPermitted(\u0026#34;lightsaber:wield\u0026#34;)) { log.info(\u0026#34;You may use a lightsaber ring. Use it wisely.\u0026#34;); } else { log.info(\u0026#34;Sorry, lightsaber rings are for schwartz masters only.\u0026#34;); } //a (very powerful) Instance Level permission: if (currentUser.isPermitted(\u0026#34;winnebago:drive:eagle5\u0026#34;)) { log.info(\u0026#34;You are permitted to \u0026#39;drive\u0026#39; the winnebago with license plate (id) \u0026#39;eagle5\u0026#39;. \u0026#34; + \u0026#34;Here are the keys - have fun!\u0026#34;); } else { log.info(\u0026#34;Sorry, you aren\u0026#39;t allowed to drive the \u0026#39;eagle5\u0026#39; winnebago!\u0026#34;); } //all done - log out! currentUser.logout(); System.exit(0); Securing Web Applications with Apache Shiro project apache-shiro-tutorial-webapp\nrun the app\n1 mvn jetty:run Step 1: Enable Shiro 1 $ git checkout step1 web.xml content added, shiro.ini added\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.apache.shiro.web.env.EnvironmentLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;ShiroFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.apache.shiro.web.servlet.ShiroFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;ShiroFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;dispatcher\u0026gt;REQUEST\u0026lt;/dispatcher\u0026gt; \u0026lt;dispatcher\u0026gt;FORWARD\u0026lt;/dispatcher\u0026gt; \u0026lt;dispatcher\u0026gt;INCLUDE\u0026lt;/dispatcher\u0026gt; \u0026lt;dispatcher\u0026gt;ERROR\u0026lt;/dispatcher\u0026gt; \u0026lt;/filter-mapping\u0026gt; 1 2 3 4 5 6 7 8 [main] # Let\u0026#39;s use some in-memory caching to reduce the number of runtime lookups against Stormpath. A real # application might want to use a more robust caching solution (e.g. ehcache or a distributed cache). When using such # caches, be aware of your cache TTL settings: too high a TTL and the cache won\u0026#39;t reflect any potential # changes in Stormpath fast enough. Too low and the cache could evict too often, reducing performance. cacheManager = org.apache.shiro.cache.MemoryConstrainedCacheManager securityManager.cacheManager = $cacheManager Step 2: Connect to a User Store 1 $ git checkout step2 Stormpath is a cloud hosted user management service, totally free for development purposes.\nThis means that after enabling Stormpath, you’ll have the following ready to go:\nA user interface for managing Applications, Directories, Accounts and Groups. Shiro does not provide this at all, so this will be convenient and save time while you go through this tutorial.\nA secure storage mechanism for user passwords. Your application never needs to worry about password security, password comparisons or storing passwords. While Shiro can do these things, you would have to configure them and be aware of cryptographic concepts. Stormpath automates password security so you (and Shiro) don’t need to worry about it or be on the hook for \u0026lsquo;getting it right\u0026rsquo;.\nSecurity workflows like account email verification and password reset via email. Shiro has no support for this, as it is often application specific.\nHosted/managed \u0026lsquo;always on\u0026rsquo; infrastructure - you don’t have to set anything up or maintain anything.\npass\n","date":"2025-02-10T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/apache-shiro/cover_hu10467585328043985690.png","permalink":"https://yangzhaoxing90.github.io/p/apache-shiro/","title":"Apache Shiro"},{"content":"站点资源 学习资源站 https://youkn0wwho.academy/topic-list\n刷题站 https://vjudge.net/\nBasics What is Programming？ pass Intro to C++ and Setting up the Environment 最后还是选择了用 vscode + glang 进行编译的方式 Data Types, Variables and Input Output 掌握基本的输入输出语法 (cin, cout) 基本数据类型 (int, long long, char, float, double) 掌握变量的用法 (const, \u0026hellip;) Operators 算术操作符 (+,-,*,/,%) 赋值操作符 (=，+=，-=，*=，/=，%=) 关系运算符 (==,!=,\u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=) 逻辑运算符 (\u0026amp;\u0026amp;,||,!) 比特操作运算符 (\u0026amp;,|,^,~,\u0026laquo;,\u0026raquo;) 其他特殊操作符 (sizeof,?:,\u0026amp;,.,-\u0026gt;,\u0026laquo;,\u0026raquo;) Conditional Statements if else switch case Loops for while do while ","date":"2025-02-08T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/topic-list/cover_hu5334211331950979651.png","permalink":"https://yangzhaoxing90.github.io/p/topic-list/","title":"Topic list"},{"content":"参考资源 旅游计划制定基础思路\n相关项目去哪些网站预定 国内：携程、飞猪、去哪了\n国际：Expedia、Booking、Agoda\n以上这些网站可以预定旅游中所需要的一切项目 （机票、酒店、民宿、车票、船票、租车等等）\n租车：微信、支付宝等，神州租车等独立的租车公司 （国外推荐 Avis 和 Hertz）\n国外特殊项目：Airbnb\n省钱的窍门 返利网站：TopCashback （英国返利网站）\n如何规划旅行时长 pass\n行程计划表 找准旅游的重点 想看风景，还是体验文化，还是体验美食等等\n多景点路径规划 使用地图软件\n旅游好物分享 卫生用品：小包的湿巾、酒精湿巾、湿厕纸\n住宿用品：小的烧水壶、折叠的衣架、淋浴拖鞋\n极力推荐：旅行睡袋 【mido house】（可以不用接触到卫生条件较差的酒店的被子等）\n了解目的地的文化习俗 如：美国的小费文化\n总结 确定旅游的重点 确定旅游的时间范围 借助相关网站确定旅游路线，食住行以及特殊项目等，同时绘制行程计划表和行程进度表 查看能否利用返利网站省钱 带好该带的东西 了解目的地的文化习俗 出发 ","date":"2025-02-08T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92%E5%88%B6%E5%AE%9A%E5%9F%BA%E7%A1%80/cover_hu15959000950015708700.jpg","permalink":"https://yangzhaoxing90.github.io/p/%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92%E5%88%B6%E5%AE%9A%E5%9F%BA%E7%A1%80/","title":"旅游计划制定基础"},{"content":"Netty 服务端构建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class NettyServer { public static void main(String[] args) { /** * 新建两个线程组, boss 线程启动一条线程, 监听 OP_ACCEPT 事件 * Worker 线程组默认启动 CPU 核数*2 的线程 * 监听客户端连接的 OP_READ 和 OP_WRITE 事件, 处理 I/O 事件 */ EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { // Netty 服务启动辅助类 ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup); // 设置 TCP Socket 通道为 NioServerSocketChannel // 若是 UDP 则设置为 DatagramChannel serverBootstrap.channel(NioServerSocketChannel.class); // 设置一些 TCP 参数 serverBootstrap.option(ChannelOption.SO_BACKLOG, 128) .childHandler(new ChannelInitializer\u0026lt;SocketChannel\u0026gt;() { @Override protected void initChannel(SocketChannel ch) throws Exception { /** * 向 Worker 线程的管道双链表中添加处理类 ServerHandler * 整个处理流向如下：HeadContext-channelRead读数据 --\u0026gt; ServerHandler-channelRead * 读取数据进行业务逻辑判断，最后将结果返回给客户端 --\u0026gt; TailContext-write-\u0026gt; * HeadContext-write */ ch.pipeline().addLast(new ServerHandler()); } }); // 同步绑定端口 ChannelFuture future = serverBootstrap.bind(8080).sync(); // 阻塞主线程直到 Socket 通道关闭 future.channel().closeFuture().sync(); } catch (Exception e) { } finally { workerGroup.shutdownGracefully(); bossGroup.shutdownGracefully(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ServerHandler extends ChannelInboundHandlerAdapter { /** * 读取客户端发送的数据 */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) { if (msg instanceof ByteBuf) { // 把 二进制数据 转成字符串，默认编码 UTF-8 System.out.println(((ByteBuf) msg).toString(Charset.defaultCharset())); } ctx.channel().writeAndFlush(\u0026#34;msg has received!\u0026#34;); } } Netty 客户端的应用 Netty 除了可以编写高性能服务端，还有配套的非阻塞I/O客户端\n关于客户端和服务端的通信，涉及到多线程数据交互，并运用了 JDK 的锁和多线程\nJava 多线程交互的例子 模拟 1 条主线程循环写数据，另外 99 条子线程，每条子线程模拟睡眠 1s，再给主线程发送结果\n最终主线程阻塞获取 99 条子线程响应的结果数据\nFutureMain: 主线程, 拥有启动 main() 方法的实例和总体处理逻辑\nRequestFuture: 模拟客户端请求类, 主要用于构建请求对象, 核心在于它的同步等待和结果通知\nSubThread: 子线程, 用于模拟服务器处理, 根据 RequestFuture 构建响应结果\nResponse: 响应结果类\nNetty 客户端服务端的交互流程 ","date":"2025-02-07T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/netty-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/cover_hu14628912385329313796.png","permalink":"https://yangzhaoxing90.github.io/p/netty-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/","title":"Netty 源码剖析与应用"},{"content":"获取 springboot 源码 idea 中创建 springboot 项目，引入 springboot 的 pom 依赖，然后 maven 下载源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.18\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-autoconfigure-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-autoconfigure-processor\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 获取了 springboot 2.7.18 的源码\nspringboot 的核心运行逻辑 Spring Boot 最核心的功能就是自动装配，基于 \u0026ldquo;约定优于配置\u0026rdquo; 的原则\n使用 Spring Boot 的时候，只需要引入对应的 Starters ，Spring Boot 启动时就会自动加载相关的依赖，配置相应的初始化参数\n以最快捷、简单的形式对第三方软件进行集成\n入口类\n由 @SpringBootApplication 注解的类 main() 函数，Spring Boot 项目的入口函数 @SpringBootApplication\n包含了 @EnableAutoConfiguration 注解 exclude 排除指定配置类 excludeName 排除指定配置类名 scanBasePackages 指定扫描基础包，激活注解组件的初始化 scanBasePacakgeClasses 指定扫描的类，用于初始化 proxyBeanMethods 指定是否代理 @Bean 方法以强制执行 bean 的生命周期行为 包含了 @ComponentScan 包含了 @SpringBootConfiguration 组合了 @Configuration @AliasFor 注解\n用于桥接到其他注解，该注解的属性中指定了所桥接的注解类 可以减少用户使用多注解带来的麻烦 @EnableAutoConfiguration 注解\nSpring 无法自动配置 @Configuration 注解的类，该注解可以根据约定自动管理它 主要功能是启动 Spring 应用程序上下文的时候进行自动配置 ENABLED_OVERRIDE_PROPERTY 用来开启/关闭自动配置 exclude 排除指定配置类 excludeName 排除指定配置类名 @EnableAutoConfiguration 注解的类所在的包，会作为 @Entity 被扫描的根路径，所以需要放到最外面 AutoConfigurationlmportSelector 类 @Import 注解\n主要提供导入配置类的功能 和 xml 中的 作用一样，可以通过 @Import 引入 @Configuration 注解的类 也可以导入实现 ImportSelector 或 ImportBeanDefinitionRegistrar 的类 还可以通过 @Import 导入 POJO ImportSelector 接口\nImportSelector 决定可以引入哪些 @Configuration String[] selectImports(AnnotationMetadata importingClassMetadata) AnnotationMetadata 内包含了被 @Import 注解的类的注解信息 实现 ImportSelector 的同时又实现了 Aware 接口, Spring 保证会在调用 ImportSelector 之前会先调用 四个 Aware 方法 AutoConfigurationImportSelector 类\n实现了 4 个 Aware 接口 实现了 DeferredImportSelector 接口，与 ImportSelector 的区别是前者会在所有 @Configuration 加载完之后再加载返回的配置类 ImportSelector 会在之前去加载返回的配置类 DefferedImportSelector 提供了 getImportGroup 实现自定义的 Configuration 加载顺序，也可通过 @Order 注解或 Ordered 接口来指定加载顺序 @Conditional 条件注解\n可以根据是否满足指定的条件决定是否进行 Bean 的实例化及装配 Condition 数组，的 matches 方法全部返回 true，该注解的类才会被加载 Spring Boot 构造流程源码分析 Spring 启动时都做了些什么，从 main() 开始\nSpringApplication\nrun 方法 实例化流程 定制化配置 ApplicationContextInitializer 加载\nSpringIOC 容器提供的接口，允许用于在 ConfigurableApplicationContext 类型的 ApplicationContext 做 refresh 之前进行设置 ApplicationListener 加载\n容器初始化完成后，需要处理一些数据的加载、初始化缓存、特定任务的注册等操作 Spring Boot 运行流程源码分析 SpringApplicationRunListeners ApplicationArguments ConfigurableEnvironment SpringApplicationRunListeners 监听器\n提供了针对 Listener 的各种遍历操作 它是 run 方法的监听器 EventPublishingRunListener\n使用内建的 SimpleApplicationEventMulticaster 来广播在上下文刷新之前触发的事件 初始化完成后，会遍历 SpringApplication 的所有 ApplicationListener 实例，将它们与 SimpleApplicationEventMulticaster 进行关联 ApplicationArguments\nDefaultApplicationArguments(args) ConfigurableEnvironment\n提供当前运行环境的公开接口，如配置文件 profiles 的各类系统属性和变量的设置、添加、读取、合并等功能 ","date":"2025-02-06T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/springboot-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%86%85%E5%B9%95/cover_hu16075223468926870913.png","permalink":"https://yangzhaoxing90.github.io/p/springboot-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%86%85%E5%B9%95/","title":"Springboot 技术架构内幕"},{"content":"参考旅游计划制定基础的内容进行云南旅游制定\n旅游的目的 （重点） 体验不同地方的人文，看看不太常见的风景，放松身心，吃当地特色美食\n旅游时间 2026.02.11 (南小年) - 2026.02.15 (除夕前)\n总计5日4晚\n根据携程思考旅游计划 最为轻松的方式，直接用携程推荐的旅游方案：\n私家团方案 跟团游方案 包车自由行方案 根据飞猪思考旅游计划 感觉飞猪的方案不如携程多，直接 pass\n根据去哪儿思考旅游计划 感觉也不如携程，以后都用携程好了，这些就参考参考价格还有攻略啥的\n携程上的方案罗列 考虑到可能要带 1 岁的娃出门，所以考虑去海拔比较低的地方 昆明、大理、丽江古城、泸沽湖、西双版纳、普洱\n查询到携程上的云南旅游方案\n方案 类型 价格 路径 云南西双版纳5日4晚私家团 私家团 12788 丽江+大理市+玉龙雪山+洱海5日4晚自由行 自由行 8843.5 云南西双版纳+普洱5日4晚私家团 私家团 11476 昆明+大理市+丽江+香格里拉+玉龙雪山5日4晚私家团 私家团 13287 昆明+大理市+丽江5日4晚自由行 自由行 6887 感觉携程上的旅游方案价格较贵，所以最终决定一个行程参考，但是自己制定路线的方式\n行程计划表制定 ","date":"2025-02-06T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E4%BA%91%E5%8D%97%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/cover_hu7165935331824467978.jpeg","permalink":"https://yangzhaoxing90.github.io/p/%E4%BA%91%E5%8D%97%E6%97%85%E6%B8%B8%E8%AE%A1%E5%88%92/","title":"云南旅游计划"},{"content":"遛娃推荐文章 19楼帖子\n遛娃记录 日期 地点 行程 感想 2025-01-05 xxx 自驾到 xxx, 途径 xxx, xxx, 然后返程, 耗时 xxx xxx 很不错, xxx 差点意思 \u0026hellip; ![图片] ","date":"2025-02-06T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E6%9D%AD%E5%B7%9E%E9%81%9B%E5%A8%83%E8%AE%B0%E5%BD%95/cover_hu13091905212183973098.jpg","permalink":"https://yangzhaoxing90.github.io/p/%E6%9D%AD%E5%B7%9E%E9%81%9B%E5%A8%83%E8%AE%B0%E5%BD%95/","title":"杭州遛娃记录"},{"content":"Determninants Number Fields Number Field axioms:\n$a$. To every pair of numbers $\\alpha$ and $\\beta$ in $K$ there corresponds a (unique) number $\\alpha + \\beta$ in $K$, called sum of $\\alpha$ and $\\beta$\n$\\alpha + \\beta = \\beta + \\alpha$ for every $\\alpha$ and $\\beta$ in $K$ (addition is commutative) $(\\alpha + \\beta) + \\gamma = \\alpha + (\\beta + \\gamma) $ for every $ \\alpha, \\beta, \\gamma $ in $K$ (addition is associative) There exists a number number $0$ (zero) in $K$ such that $ 0 + \\alpha = \\alpha $ for every $\\alpha$ in $K$ For every $\\alpha$ in $K$, there exists a number (negative element) $\\gamma$ in $K$ such that $\\alpha + \\gamma = 0$ $b$. To every pair of numbers $\\alpha$ and $\\beta$ in $K$ there conrresponds a (unique) number $\\alpha \\cdot \\beta$ (or $\\alpha\\beta$) in $K$, called the product of $\\alpha$ and $\\beta$\n$\\alpha\\beta = \\beta\\alpha$ for every $\\alpha$ and $\\beta$ in $K$ (multiplication is commutative) $(\\alpha\\beta)\\gamma$ = $\\alpha(\\beta\\gamma)$ for every $\\alpha, \\beta, \\gamma$ in $K$ (multiplication is associative) There exits a number $1 (\\not= 0)$ in $K$ such that $1 \\cdot \\alpha = \\alpha$ for every $\\alpha$ in $K$ For every $\\alpha \\not= 0$ in $K$ there exists a number (reciprocal element) $\\gamma$ in $K$ such that $\\alpha\\gamma = 1$ $c$. Multiplication is distributive over addition, i.e\n$\\alpha(\\beta + \\gamma)$ = $\\alpha\\beta$ + $\\alpha\\gamma$ for every $\\alpha, \\beta, \\gamma$ in $K$ nattural: the numbers, 1, 1+1=2, 2+1=3, etc. It\u0026rsquo;s assumed that none of these numbers is zero.\nintegers: the set of all natural numbers together with thier negatives and the number zero.\nrational: the set of all quotients, $\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\not= 0$\n","date":"2025-02-05T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/linear-algebra/cover_hu7061021367063827890.png","permalink":"https://yangzhaoxing90.github.io/p/linear-algebra/","title":"linear algebra"},{"content":"引言 https://github.com/MingchaoZhu/DeepLearning?tab=readme-ov-file\nAI 深度学习： 层次化的概念形成的图的方法\n知识库：用形式化的语言对关于世界的知识进行硬编码\n机器学习：从原始数据中，自己提取模式的能力\n表示学习：使用机器学习来发掘表示本身\n深度学习的历史趋势 控制论 (简单的线性模型)\n$$ f(x, w) = x_1w_1 + ... + x_nw_n $$线性代数 标量: 就是一个单独的数\n向量: 是一列数\n$$ x = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ . \\\\ . \\\\ . \\\\ x_n \\end{bmatrix} $$矩阵: 是一个二维数组\n$$ \\begin{bmatrix} A_{1,1} \u0026 A_{1,2} \\\\ A_{2,1} \u0026 A_{2,2} \\end{bmatrix} $$张量: 超过两维的数据 $A_{i,j,k}$\n转置: 对角线为轴的镜像\n$$ (A^T)_{i,j} = A_{j,i} $$矩阵乘法\n$ C = AB $\n$$ C_{i,j} = \\sum_{ \\begin{subarray}{l} k \\end{subarray}}A_{i,k}B_{k,j} $$矩阵点积\n$$ x^Ty $$线性方程组\n$$ Ax = b $$","date":"2025-02-05T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/cover_hu8320576161981173177.jpg","permalink":"https://yangzhaoxing90.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","title":"深度学习"},{"content":"QFluent 资源站 github: https://github.com/zhiyiYo/PyQt-Fluent-Widgets\n官网: https://qfluentwidgets.com/zh/pages/install\n安装 1 2 3 4 5 # 安装轻量版 pip install PySide6-Fluent-Widgets -i https://pypi.org/simple/ # 安装完整版 pip install \u0026#34;PySide6-Fluent-Widgets[full]\u0026#34; -i https://pypi.org/simple/ 下载源代码 1 git clone https://github.com/zhiyiYo/PyQt-Fluent-Widgets.git 运行示例 1 2 cd examples/gallery python demo.py 如何入门 掌握 Qt 的信号槽机制、事件机制、按钮和输入框等常用组件的使用 安装组件库并下载 GitHub 仓库 源代码 阅读并运行 examples 文件夹中的实例 阅读官网文档 除了 InfoBar、Pivot 和 FluentWindow 等自定义组件需要阅读文档外，按钮、输入框和标签这种组件仅仅是修改了样式表或重写了 paintEvent，API 与 Qt 内置组件保持一致，只要修改类名为 QFluentWidgets 的组件名即可，没有任何额外的学习成本\n","date":"2025-01-21T16:00:00Z","image":"https://yangzhaoxing90.github.io/p/qfluentwidgets-%E6%95%99%E7%A8%8B/fluent_hu1460194419458193413.png","permalink":"https://yangzhaoxing90.github.io/p/qfluentwidgets-%E6%95%99%E7%A8%8B/","title":"QFluentWidgets 教程"},{"content":"Getting started with PySide6 reference: https://www.pythonguis.com/tutorials/pyside6-creating-your-first-window/\nCreating your first app with PySide6 Creating an application\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from PySide6.QtWidgets import QApplication, QWidget # Only needed for access to command line arguments import sys # You need one (and only one) QApplication instance per application. # Pass in sys.argv to allow command line arguments for your app. # If you know you won\u0026#39;t use command line arguments QApplication([]) works too. app = QApplication(sys.argv) # Create a Qt widget, which will be our window. window = QWidget() window.show() # IMPORTANT!!!!! Windows are hidden by default. # Start the event loop. app.exec() What\u0026rsquo;s the event loop?\nQApplication object to function. This object holds the event loop of your application — the core loop which governs all user interaction with the GUI.\nEvent queue: whether a press of a key, click of a mouse, or mouse movement — generates an event which is placed on the event queue.\nEvent handler: The event handler deals with the event, then passes control back to the event loop to wait for more events\nEvent loop: There is only one running event loop per application. In the event loop, the queue is checked on each iteration and if a waiting event is found, the event and control is passed to the specific event handler for the event.\nQMainWindow\nThis is a pre-made widget which provides a lot of standard window features you'll make use of in your apps, including toolbars, menus, a statusbar, dockable widgets and more 1 2 3 4 5 6 7 8 9 10 import sys from PySide6.QtWidgets import QApplication, QMainWindow app = QApplication(sys.argv) window = QMainWindow() window.show() # Start the event loop. app.exec() add some content\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import sys from PySide6.QtCore import QSize, Qt from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton # Subclass QMainWindow to customize your application\u0026#39;s main window class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#34;My App\u0026#34;) button = QPushButton(\u0026#34;Press Me!\u0026#34;) # Set the central widget of the Window. self.setCentralWidget(button) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Sizing windows and widgets\n1 2 3 from PySide6.QtCore import QSize, Qt self.setFixedSize(QSize(400, 300)) PySide6 Signals, Slots \u0026amp; Events QPushButton Signals 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import sys from PySide6.QtWidgets import QApplication, QMainWindow, QPushButton class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#34;My App\u0026#34;) button = QPushButton(\u0026#34;Press Me!\u0026#34;) button.setCheckable(True) button.clicked.connect(self.the_button_was_clicked) # Set the central widget of the Window. self.setCentralWidget(button) def the_button_was_clicked(self): print(\u0026#34;Clicked!\u0026#34;) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Receiving data 1 2 3 4 5 6 7 button = QPushButton(\u0026#34;Press Me!\u0026#34;) button.setCheckable(True) button.clicked.connect(self.the_button_was_clicked) button.clicked.connect(self.the_button_was_toggled) def the_button_was_toggled(self, checked): print(\u0026#34;Checked?\u0026#34;, checked) Storing data 1 2 3 4 5 6 7 8 9 button = QPushButton(\u0026#34;Press Me!\u0026#34;) button.setCheckable(True) button.clicked.connect(self.the_button_was_toggled) button.setChecked(self.button_is_checked) def the_button_was_toggled(self, checked): self.button_is_checked = checked print(self.button_is_checked) Changing the interface 1 2 3 4 5 6 7 8 self.button.clicked.connect(self.the_button_was_clicked) def the_button_was_clicked(self): self.button.setText(\u0026#34;You already clicked me.\u0026#34;) self.button.setEnabled(False) # Also change the window title. self.setWindowTitle(\u0026#34;My Oneshot App\u0026#34;) Events Event handler Event type method mouseMoveEvent() Mouse moved mousePressEvent() Mouse button pressed mouseReleaseEvent() Mouse button released mouseDoubleClickEvent() Double click detected 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import sys from PySide6.QtWidgets import QApplication, QLabel, QMainWindow class MainWindow(QMainWindow): def __init__(self): super().__init__() self.label = QLabel(\u0026#34;Click in this window\u0026#34;) self.setCentralWidget(self.label) def mouseMoveEvent(self, e): self.label.setText(\u0026#34;mouseMoveEvent\u0026#34;) def mousePressEvent(self, e): self.label.setText(\u0026#34;mousePressEvent\u0026#34;) def mouseReleaseEvent(self, e): self.label.setText(\u0026#34;mouseReleaseEvent\u0026#34;) def mouseDoubleClickEvent(self, e): self.label.setText(\u0026#34;mouseDoubleClickEvent\u0026#34;) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() More Events Method Returns .button() Specific button that triggered this event .buttons() State of all mouse buttons (OR\u0026rsquo;ed flags) .globalPos() Application-global position as a QPoint .globalX() Application-global horizontal X position .globalY() Application-global vertical Y position .pos() Widget-relative position as a QPoint integer .posF() Widget-relative position as a QPointF float 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import sys from PySide6.QtCore import Qt from PySide6.QtWidgets import QApplication, QLabel, QMainWindow class MainWindow(QMainWindow): def __init__(self): super().__init__() self.label = QLabel(\u0026#34;Click in this window\u0026#34;) self.setCentralWidget(self.label) def mousePressEvent(self, e): if e.button() == Qt.MouseButton.LeftButton: # handle the left-button press in here self.label.setText(\u0026#34;mousePressEvent LEFT\u0026#34;) elif e.button() == Qt.MouseButton.MiddleButton: # handle the middle-button press in here. self.label.setText(\u0026#34;mousePressEvent MIDDLE\u0026#34;) elif e.button() == Qt.MouseButton.RightButton: # handle the right-button press in here. self.label.setText(\u0026#34;mousePressEvent RIGHT\u0026#34;) def mouseReleaseEvent(self, e): if e.button() == Qt.MouseButton.LeftButton: self.label.setText(\u0026#34;mouseReleaseEvent LEFT\u0026#34;) elif e.button() == Qt.MouseButton.MiddleButton: self.label.setText(\u0026#34;mouseReleaseEvent MIDDLE\u0026#34;) elif e.button() == Qt.MouseButton.RightButton: self.label.setText(\u0026#34;mouseReleaseEvent RIGHT\u0026#34;) def mouseDoubleClickEvent(self, e): if e.button() == Qt.MouseButton.LeftButton: self.label.setText(\u0026#34;mouseDoubleClickEvent LEFT\u0026#34;) elif e.button() == Qt.MouseButton.MiddleButton: self.label.setText(\u0026#34;mouseDoubleClickEvent MIDDLE\u0026#34;) elif e.button() == Qt.MouseButton.RightButton: self.label.setText(\u0026#34;mouseDoubleClickEvent RIGHT\u0026#34;) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() Context menus Context menus are small context-sensitive menus that typically appear when right-clicking on a window.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import sys from PySide6.QtGui import QAction from PySide6.QtWidgets import QApplication, QMainWindow, QMenu class MainWindow(QMainWindow): def __init__(self): super().__init__() def contextMenuEvent(self, e): context = QMenu(self) context.addAction(QAction(\u0026#34;test 1\u0026#34;, self)) context.addAction(QAction(\u0026#34;test 2\u0026#34;, self)) context.addAction(QAction(\u0026#34;test 3\u0026#34;, self)) context.exec(e.globalPos()) app = QApplication(sys.argv) window = MainWindow() window.show() app.exec() PySide6 Widgets PySide6 Layouts PySide6 Toolbars \u0026amp; Menus — QAction PySide6 Dialogs and Alerts Creating additional windows Creating applications with Qt Designer ","date":"2025-01-21T14:00:00Z","image":"https://yangzhaoxing90.github.io/p/pyside6-tutorial/pyside_hu14271967758081850635.png","permalink":"https://yangzhaoxing90.github.io/p/pyside6-tutorial/","title":"PySide6 Tutorial"},{"content":"资源合集 资料 链接 说明 《实用程序育儿法》 https://zhuanlan.zhihu.com/p/157568332 经典的\u0026quot;E.A.S.Y.模式\u0026quot; 《宝宝睡眠圣经》 https://www.scribd.com/document/721699362/%E5%A9%B4%E5%B9%BC%E5%84%BF%E7%9D%A1%E7%9C%A0%E5%9C%A3%E7%BB%8F 提供分阶段的睡眠训练方法 《婴幼儿睡眠的秘密》 https://weread.qq.com/ 提供本土化解决方案 实用程序育儿法 E.A.S.Y.未必容易，但是管用! 让宝宝按有规律的常规程序作息\n吃 (Eat), 活动 (Activity), 睡觉 (Sleeping), 给自己一点时间 (You)\nE.A.S.Y 不适合晚上，晚上应该直接跳过活动的环节\n不能让婴儿遵守时间\n4个月以前： - 3小时一个流程，吃 （30min），活动（30min），小睡（1.5-2小时） - 4次小睡\n4个月以后： -\n即使婴儿也有情感 教宝宝如何睡觉 抱起-放下睡眠训练工具 (4个月-1岁) 我们依然睡眠不足 (1岁以后的睡眠问题) ","date":"2024-02-02T11:30:00Z","image":"https://yangzhaoxing90.github.io/p/%E5%A9%B4%E5%84%BF%E5%93%84%E7%9D%A1%E6%80%BB%E7%BB%93/cover_hu8763926118169480008.jpg","permalink":"https://yangzhaoxing90.github.io/p/%E5%A9%B4%E5%84%BF%E5%93%84%E7%9D%A1%E6%80%BB%E7%BB%93/","title":"婴儿哄睡总结"},{"content":"新生儿护理材料总结 资料 护理相关内容 《西尔斯亲密育儿》 换尿布、脐带护理、指甲护理、洗澡、按摩、呼吸模式、排泄模式、体重、吐奶、喂奶、睡眠 《美国儿科学会育儿百科》 婴儿哭闹、婴儿睡姿、尿布、排尿、排便、洗澡、保养皮肤、剪指甲、穿衣服、基本医疗护理 ","date":"2024-01-14T11:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E6%96%B0%E7%94%9F%E5%84%BF%E6%8A%A4%E7%90%86%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/cover_hu14258836955209789646.jpg","permalink":"https://yangzhaoxing90.github.io/p/%E6%96%B0%E7%94%9F%E5%84%BF%E6%8A%A4%E7%90%86%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/","title":"新生儿护理资源合集"},{"content":"网络基础知识 计算机网络出现的背景：\n计算机普及 计算机间信息共享的需求 (从局域网到广域网) 私有网络发展为互联网 协议是什么：\n例如： TCP/IP/HTTP \u0026hellip; 协议的必要性 (计算机通信时的约定，计算机间遵守相同的协议就能通信) 分组交换协议 (将通信的数据分割成一个个包作为较小的单位进行传输) 协议由谁规定:\n计算机通信的最初, 每家厂商都自己产出网络产品进行通信, 没有标准化 ISO 制定了 OSI 国际标准, 对通信系统进行了标准化 TCP/IP 标准化是由 IEFT 所推进的 协议分层：\n协议分层模型，每层都接受它下层提供的服务，并负责为它的上层提供服务 上下层的交互所遵循的约定叫接口，同层交互所遵循的约定叫协议 OSI 参考模型：\nOSI 将复杂的通信协议分成了易于理解的 7 层 OSI 参考模型和 OSI 协议不是一回事 OSI 各层的作用：\n应用层 (电子邮件协议、远程登录协议、文件传输协议， 是针对每个应用的协议) 表示层 (设备固有格式到网络标准格式的转换) 会话层 (通信管理，负责建立和断开通信连接) 传输层 (管理两个节点间的数据传输，负责可靠传输) 网络层 (地址管理、路由选择) 数据链路层 (数据帧和比特流转换) 物理层 (比特流和电子信号转换) 传输方式分类：\n面向有连接（发送数据前需要建立通信线路）和面向无连接 （发送端自由发送数据） 电路交换 (电话网，过时) 和分组交换 电路交换：\n通信线路是独占的，计算机之间的通信效率低 通过交换机建立通信电路 分组交换：\n将数据分成多个数据包，按照一定顺序排列之后分别发送 所有计算机可以一起收发数据，提高了通信线路的利用率 分组交换中由(分组交换机)路由器连接通信线路 传输方式根据接收端的数据分类：\n单播 (Unicast) (1对1通信) 广播 (Broadcast) (1对多通信) 任播 (Anycast) （组内任选一台） 地址:\n每层协议地址不同，TCP/IP 的 MAC 地址， IP地址，端口号等；应用层可以将电子邮件作为地址 地址的唯一性 （单播、广播、任播，如何实现地址唯一） 地址的层次性 （MAC地址、IP地址的分层） 地址的唯一性：\n单播的例子 （一年级一班的xxx同学请起立） 多播的例子 （一年级一班同学请起立） 任播的例子 （一年级一班的哪位同学请起立） 地址的层次性：\nIP 地址由网络号和主机号两部分组成 MAC 地址由制造商识别号、制造商内部产品编号和产品通用编号确保唯一性 网络的构成要素：\n网卡 使得计算机联网的设备 中继器 物理层上延长网络的设备 网桥/2层交换机 数据链路层上延长网络的设备 路由器/3层交换机 通过网络层转发数据分组 4~7 层交换机 处理传输层以上各层网络传输的设备 网关 转换协议的设备 传输速率和吞吐量：\n传输速率 （带宽）（相当于通车的车道，车道越多一次允许通过的车辆越多） 吞吐量就是实际传输速率, 还包含了 cpu 的处理能力、网络的拥堵程度、报文中数据字段的占用份额等 网卡：\n网络接口卡 (NIC), 也叫 网络适配器、网卡、LAN 卡 现今计算机都内置网卡，用于计算机连入网络 中继器：\n电信号或光信号经过中继器放大再传给另一个电缆 物理层设备 不能在传输速度不同的媒介中转发 网桥：\n数据链路层设备 能够识别数据帧，临时存于内存，然后生成新的数据帧，转发给相连的另一个网段 数据帧中的数据位 FCS 用于校验数据是否正确达到目的地 网桥还能通过地址自学机制和过滤功能控制网络流量 这里的地址是 MAC 地址、硬件地址、物理地址和适配器地址， NIC 分配的具体地址 路由器：\n网络层设备 对分组报文进行转发 路由器可以连接不同的数据链路 路由器还有可以分担网络负荷的作用 4～7 层交换机：\n传输层至应用层设备 分析收发数据，并对其进行特殊处理 （如负载均衡器） 带宽控制、广域网加速器、特殊应用访问加速、防火墙 网关：\n传输层到应用层的数据进行转换和转发的设备 如互联网邮箱和手机邮箱的转换 代理服务器，防火墙 网络的构成：\n边缘网络 （高速公路的出入口） 主干网络 （高速公路） TCP/IP 基础知识 计算机厂商跟风支持 TCP/IP 的历史原因：\n军用技术 （美国国防部），使用迂回线路替代中心线路，防止整个网络一点破坏和瘫痪 ARPANET 的诞生，分组交换技术的应用，巨大规模网络的鼻祖 TCP/IP 诞生， ARPANET 的唯一指定协议 Unix 系统的普及 商用互联网服务 TCP/IP 的标准化：\nIP、ICMP、TCP、UDP、TELNET、FTP 以及 HTTP 都属于 TCP/IP 族 开放性和实用性两大特点 IEFT 讨论制定 TCP/IP 的开放性 RFC文档记录了协议的内容，实现和运用，以及实验相关信息，通过编号组织每个协议的标准化请求 若是要修改协议内容，要发一个新的 RFC 文档，老的作废 STD 编号用来记载哪个编号制定哪个协议 TCP/IP 的标准化流程：\n一个协议的标准化一定要经过 IETF 讨论 互联网草案阶段，如果认为可以进行标准化 （6个月） 就记入 RFC 进入提议标准阶段 （IESG IETF 的主要成员的批准，就能被编入 RFC） 草案标准阶段 最后才是真正的标准阶段 RFC 的获取方法：\nhttp://www.rfc-editor.org/rfc/ http://www.rfc-editor.org/in-notes/std/ http://www.rfc-editor.org/in-notes/fyi http://www.rfc-editor.org/internet-drafts/ 互联网:\n由 ARPANET 网发展而来，互连全世界的计算机网络 互联网的每个网络都是骨干网和末端网组成，每个网络通过 NOC 相连，连接异构网络需要用 IX 的支持 TCP/IP 协议分层模型\nOSI 参考模型 TCP/IP 物理层\n负责传输数据的硬件 TCP/IP 网络接口层 (数据链路层)\n让 NIC 起作用的驱动程序 互联网层 （网络层）\nIP 协议 （主机的标识） ICMP 协议 （网络健康诊断） ARP 协议 （从IP中解析MAC地址的协议） TCP/IP 传输层\nTCP 协议 （面向有连接的传输协议） UDP 协议 （面向无连接的传输协议） TCP/IP 应用层\nWWW HTTP HTML SMTP FTP 远程登录 （TELENT 和 SSH） SNMP TCP/IP 通信示例\n数据包首部 （每个分层都会在数据包前附加一个首部） 应用程序发送数据包 -\u0026gt; 附加 TCP 首部 -\u0026gt; 附加 IP 首部 -\u0026gt; 附加以太网首部 -\u0026gt; 发送到目标主机 -\u0026gt; 解析以太网首部 -\u0026gt; 解析 IP 首部 -\u0026gt; 解析 TCP 首部 -\u0026gt; 获取信息 数据链路 TCP/IP 对数据链路及以下部分 (物理层) 未做定义\n数据链路层协议定义了通过通信媒介互连的设备之间传输的规范\n数据链路通信媒介\n双绞线电缆 同轴电缆 光纤 电波 红外线 各个设备间也会通过交换机、网桥、中继器等中转数据\nOSI 中数据链路层的相关技术\nMAC寻址 介质共享 非公有网络 分组交换 环路检测 VLAN 数据链路层传输方式\n以太网 WLAN PPP 数据链路可以视为网络传输中的最小单位\nMAC 地址 （用于识别数据链路中互连的节点）\n厂商识别码 (OUI) http://standards.ieee.org/develop/regauth/oui/pubic.html http://standards.ieee.org/develop/regauth/oui/index.html 共享介质型网络\n指由多个设备共享一个通信介质的一种网络 两种介质访问控制方式： 争用方式、令牌传递方式 争用方式，指争夺获取数据传输的权利 （CSMA），采用先到先得的方式占用信道发送数据 CSMA/CD 方式，发生冲突则立即释放信道，再重新争用 令牌传递方式， 只有获得令牌才能发送数据 非共享介质型网络\n对介质采用一种传输控制的方式 每个站直连交换机，由交换机负责转发数据帧 根据MAC地址转发\n交换集线器，以太网交换机 转发表 （根据MAC地址决定发送接口） 环路检测技术\n生成树的方式： IEEE802.1D定义，每个网桥必须在 1-10s 内相互交换 BPDU 包，从而判断哪些端口使用或不使用，以便消除环路 一旦发生故障，则自动切换通信线路，利用没有被使用的端口继续进行传输 源路由法 VLAN\n使用带有 VLAN 技术的网桥，就可以不用修改实际的布线，只需要修改网络的结构就行了 VLAN 就是根据交换机不同的端口，区分成不同的网段 以太网\nIEEE 802.3 规范的以太网被称为 802.3 以太网 以太网普及之初，使用同一根同轴电缆的共享介质的连接方式 现在一般采用终端与交换机之间，独占电缆的方式 以太网的分类\n10BASE，100BASE，指的是传输速率 以太网帧格式\n前段叫前导码，表示一个以太帧的开始，8个字节 前导码末尾是 SFD 域，它的值是 11 前导码后面是帧的本体，本体的前端是首部，14个字节，6个字节的目标MAC地址，6个字节的源MAC地址，2个字节的上层协议类型 帧尾是 FCS 4个字节 主要的协议类型 关于协议类型更多的细节 http://standards.ieee.org/regauth/ethertype/eth.txt http://www.iana.org/assignments/ethernet-numbers VLAN 会追加 4 个字节 (类型[16bit]、优先度[3bit]、CFI[1bit]、VLAN ID[12bit]) 无线通信\n通常采用电磁波、红外线、激光等方式进行传播 IEEE802.11定义了无线LAN IEEE802.11b 和 IEEE802.11g (2.4GHz) IEEE802.11a (5GHz) IEEE802.11n, MINO 技术 PPP\n点对点 PPP 只属于链路层的协议，不包含物理层 可以使用电话线、ISDN、专线、ATM线路、ADSL、有线电视通过 PPPoE LCP 和 NCP\nPPP 主要功能包含两个协议，不依赖上层的 LCP 和依赖上层的 NCP 若上层为 IP，NCP 也称作 IPCP LCP 主要负责建立和断开连接、设置最大接收单元、设置验证协议以及设置是否进行通信质量的监控 IPCP 则负责 IP 地址设置和是否进行 TCP/IP 首部压缩等设备 PAP 和 CHAP 通信双向验证协议 CHAP 和 OTP PPP 的帧格式\n8位字节标志码 (01111110) PPPoE\nATM\n面向连接的数据链路 以信元 (5字节首部+48字节数据) 作为单位进行传输的 POS\n一种在 SDH 上进行通信的一种协议 FDDI\n分布式光线数据接口 采用令牌环的访问方式 DAS 和 SAS 的概念 Token Ring\n令牌环网源自 IBM 开发的令牌环 LAN 技术 100VG-AnyLAN\nIEEE802.12 规范定义的一种网络协议 VG 是 Voice Grade 的缩写，指语音级 光纤通道\n实现高速数据通信的一种数据链路 HIPPI\n用于连接大型计算机 IEEE1394\n家庭局域网，也叫 FireWire, i.Link HDMI\n高清晰多媒体接口 iSCSI\n个人电脑连接硬盘的 SCSI 标准应用于 TCP/IP 网络上的一种标准 InfiniBand\n针对高端服务器的一种超高速传输接口技术 DOCSIS\n有线电视传输行业的标准 高速 PLC\n公共网络\n模拟电话线路 移动通信服务 ADSL (模拟电话) FTTH (光纤到户) 有线电视 专线 VPN (IP-VPN, 广域以太网) 公共无线 LAN X.25 帧中继 ISDN IP 协议 跨越多种数据链路，需要借助网络层\nIP 基础知识\nIP寻址 路由 IP分包与组包 IP 地址\n网络层地址信息 TCP/IP 通信中所有主机或路由器都必须设定自己的 IP 地址 不论一台主机与哪种数据链路连接，IP地址的形式都不会变 路由控制\n指的是将分组数据发送到最终目标地址的功能 路由控制表 (记录了IP数据应该发送给哪个路由器) IP 分片\nIP包比较大而不同数据链路层 MTU 不同，传输的包的大小不同 因此需要进行IP数据包的分片 IP 面向无连接\n发包之前，不需要建立与目标 IP 的连接 无连接的优点：简化、提速 IP 地址基础知识\nIPv4 地址用 32 位正整数来表示 由网络和主机两部分组成 IP 地址的分类\nA类 (0开头+7位是网络标识, 剩余24位是主机标识) B类 (10开头+14位是网络标识, 剩余16位是主机标识) C类 (110开头+21位是网络标识, 剩余8位是主机标识) D类 (1110开头+28位是网络标识, 没有主机标识) 广播地址\n","date":"2024-01-10T14:00:00Z","image":"https://yangzhaoxing90.github.io/p/%E5%9B%BE%E8%A7%A3-tcp/ip/splash_hu9907572104892523533.jpg","permalink":"https://yangzhaoxing90.github.io/p/%E5%9B%BE%E8%A7%A3-tcp/ip/","title":"图解 TCP/IP"},{"content":"第 1 章 什么是亲密育儿法 养育你自己的孩子 对读者对要求: 边学边用、适合的才是最好的、开放包容的心态来对待观点\n对作者自己的要求: 确保书中的观点是经过论证和检验的，不是一家之言\n亲密育儿七法 3个至关重要的目标:\n了解你的宝宝 让宝宝感到舒适 享受抚育宝宝的过程 让分娩成为一种情感纽带——及早与宝宝建立亲密关系 学习分娩相关知识，讨论分娩的观念 增加与宝宝的陪伴 宝宝哭声中的学问——分辨和回应宝宝发出的信号 回应宝宝的反应 婴儿不会有坏习惯，都是交流的方式 宝宝出生的前几个月及时满足他的所有需求，意味着你们之间形成了良好的交流模式 用母乳哺育你的宝宝 吃母乳长大的孩子更聪明 母乳喂养对妈妈自己也有好处，会帮助你形成母亲的直觉 把“宝宝”贴在身上——尽量多抱宝宝 婴儿背巾 和宝宝一起睡 不管宝宝睡在哪里，只要你和宝宝睡得好就行 睡眠共享 （和宝宝一起睡） 把握平衡和界限 给宝宝所有他需要的，而不是所有他想要的 不要忽略自己的需求 学会分辨关于育儿的建议 最重要的一点是学会与宝宝沟通 请爸爸们也加入亲密育儿的阵营 你可能会遇到的一些问题 亲密育儿法长期来看是最轻松的育儿法 溺爱理论是错误的，亲密无间的关系并不会影响宝宝的独立性 亲密育儿法反而能促进宝宝的独立 等宝宝长大点，再渐渐延长回应时间 亲密育儿法等好处：\n可以改善宝宝的行为 可以促进宝宝的发育 有助于宝宝的智力开发 敏感度的培养 第 2 章 安全顺产的 10 个要点 选择好的分娩环境 选择正确的接生人员 雇用专业的分娩助理 多活动 别用仰卧的姿势分娩 尝试各种分娩姿势 合理利用科学技术 慎用麻醉剂 避免做会阴侧切 做好分娩计划 第 3 章 为迎接宝宝做准备 选好你的育儿团队 选择母乳喂养还是奶瓶喂养 为宝宝搭建爱巢 第 4 章 与宝宝一起迈好第一步 宝宝的最初时刻 亲密关系 —— 什么意思， 如何建立 了解刚出生的宝宝 促进亲密关系的行为 生日 “照片” 医院的例行程序 新生儿黄疸 宝宝的第一次身体检查 第 5 章 产后全家的调适 回巢安顿 角色调整 预防和克服产后抑郁症 现在我们是三个人了 产后的身体恢复 第 6 章 照顾宝宝的身体 换尿布 把换尿布的时间变成高品质亲子时间：\n从宝宝出生到如厕练习这段时间要换 5000 块左右的尿布 喂的越频繁，换的越频繁 把换尿布的时间看作跟宝宝的交流时间 选择尿布：\n100%纯棉的尿布，外出时可以考虑用纸尿裤 换尿布：\n换尿布应该在温暖的房间、安全的平台上进行，开始前确保所有装备都在触手可及的范围内 干净的尿布 擦洗的东西，绵柔巾 垫在宝宝身下的席子或毛巾 (浴巾、隔尿垫) 对付尿布疹的药膏 （抚触油全身，如果尿布疹不退，就用含氧化锌成分的药膏） 换洗衣物 尿布围裤 尿布别针、尿布扣 安全换尿布的技巧：\n不要两只手都放开宝宝 安全处理尿布别针 （没有尿布别针，学一下怎么换尿布） 建议对换尿布不熟练的人，换的时候放地板上，安全点 勤换尿布 注意，宝宝脱的光溜溜的时候喜欢小便，手边要准备好额外的尿布或毛巾 对婴儿湿巾的提醒：有些宝宝敏感的皮肤忍受不了它们，要用无味的湿巾，使用前在温水里漂洗 当宝宝过了拉一次吃一次的阶段（第一个月末尾），喂奶前换尿布，这样宝宝吃饱后就能直接入睡，而不会被尿布打扰 给爱动的宝宝换尿布：\n为换尿布准备一个特别的节目 （唱歌等） 叼一个玩具在你嘴里，用来安抚动个不停的宝宝 放一个会动的玩具在你换尿布的地方，转移宝宝的注意力 换的时候，一边唱歌，一边用你的手指上下抚摸宝宝的腿和肚子 叫他找找他的肚脐、眼睛、鼻子等等 做个特别的、有趣的面部表情，吸引宝宝的兴趣，让他注意你的脸而不是换尿布这件事 如果宝宝动的受不了，就放地上换 脐带护理 24小时后摘掉脐带上的塑料夹子 脐带头几天会肿胀，像果冻干一样，几天后开始变干、萎缩，通常 2～3 周内彻底脱落 为了不刺激脐带，不要在肚脐周围盖上尿布或纸尿裤 用海绵给脐带擦洗 脐带脱落看到血是正常的 如果有特殊难闻的味道，就可能是感染的征兆，应该告诉医生 如果脐带周围直径 3 厘米左右的区域有红又热，肿胀，过敏，说明已经感染 指甲护理 在宝宝熟睡的时候剪他的指甲 宝宝熟睡的时候，四肢摊开，很放松，手指都是张开的 婴儿专用指甲钳比剪刀或成人用的更安全 为了不剪到指尖的皮肤，剪的时候要把宝宝的指肚压低 流点血是很难避免的，万一发生这种情况，按一按小伤口，敷点抗生素药膏 如果不剪指甲，就戴上纯棉手套，防止他抓伤自己 给宝宝洗澡 建议是先用海绵擦洗，直到脐带彻底干燥、脱落为止\n用海绵洗\n选择一个洗澡的地方，要靠近厨房或浴室，保持温暖并通风 备好必要物品 先用温水洗宝宝的脸，尤其是耳朵后面的地方、两个耳郭里面，以及脖子褶皱的地方 要是宝宝皮肤出汗、出油或者脏了，就用一块性质温和的香皂，但不要用脸上 用橄榄球式的 备好必要的物品\n两条毛巾 一块温和的香皂和婴儿洗发香波 棉球 连帽毛巾 尿布 干净衣服 在浴盆里面洗澡\n确保水温合适 唱歌，眼神交流 洗澡有关的问题\n该多长时间给宝宝洗一次澡 (一周洗一两次) 给宝宝用什么样的香皂和洗发香波 （温和型） 应该给宝宝用润肤油和爽身粉 （保湿霜） 宝宝每次洗澡时都要尖叫，怎样才能让他喜欢上洗澡 （要么很饿，要么水太烫或太冷） 让宝宝舒服 安抚奶嘴：用还是不用 恰当的接触：婴儿按摩的艺术 第 7 章 最初几周的一般护理 新生儿早期的变化 吐奶 眼睛 嘴巴 新生儿的胎记和皮疹 尿布疹的预防和治疗 第 8 章 实行母乳喂养的原因和方法 为什么母乳是最好的 为母乳喂养做准备 踏出正确的第一步 乳汁是怎么产生的 母乳喂养的常见问题 第 9 章 哺乳妈妈的选择和挑战 在哺乳期要吃好 乳汁中的敏感成分 哺乳期安全服药 哺乳好帮手 工作、喂奶两不误 挤奶 母乳喂养的挑战和快乐 特殊的孩子特别地养 断奶 第 10 章 安全而充满爱意地喂奶粉 奶粉的真相 喂多少，喂几次 冲泡配方奶 用奶瓶喂奶的技巧 让孩子脱离奶瓶 是人而不是奶瓶在喂奶 第 11 章 引入固体食物： 何时吃，吃什么，怎么吃 为什么要等 喂固体食物：6～9 个月 喂食策略 喂固体食物：9～12 个月 自制婴儿食品 市售婴儿食品 拿出杯子来 第 12 章 10招让你成为家庭营养师 给宝宝吃聪明的脂肪 给宝宝最好的碳水化合物 激活蛋白质 奠定孩子的口味 保证足够的膳食纤维 重视维生素 注意矿物质 增加铁元素 算好每一卡 养好瘦小孩 第 13 章 给学步期幼儿喂食 给挑食的宝宝喂食 让宝宝乖乖去吃饭 给学步期幼儿选择正确的乳品 你的孩子吃够了吗 食物过敏 如何让农药远离宝宝 第 14 章 把宝宝“贴”在身上：抱孩子的艺术与科学 老思想的新证据 选择合适的背景 怎样把宝宝“贴”上身；个人课程 爸爸该如何把宝宝“贴”上身——做个参与者 背宝宝的其他人选 背宝宝入睡 背宝宝做事 特殊情况 对宝宝和父母双方的好处 更好的改变你的生活方式 第 15 章 夜间育儿：如何使宝宝乖乖安睡 婴儿睡眠的事实 第 1 步：让你的宝宝有最好的开始 第 2 步：创造条件，让宝宝入睡 第 3 步：减少容易夜间醒来的因素 和宝宝一起睡——行还是不行 处理疑虑和批评 睡眠安全 疑难解答：解决宝宝的睡眠问题 关于睡眠的一些常见问题 第 16 章 照料难缠或肠痉挛的宝宝 难缠的宝宝 宝宝为什么哭闹 父母与宝宝配合 安抚宝宝 肠痉挛宝宝，或疼痛的宝宝 追踪肠痉挛的潜在成因 安抚肠痉挛宝宝 肠痉挛可以预防吗 第 17 章 工作与育儿 真正的重点：亲密关系 兼顾工作和育儿的关键 选择照顾宝宝的人 选择商业性的日托儿所 第 18 章 特殊情形的处理 照顾收养的孩子 双胞胎 单亲家庭 照顾唐氏综合征宝宝——特殊育儿方式 宝宝和宠物 第 19 章 共同成长：享受宝宝成长的各个阶段 共同成长 亲密育儿法：如何建立更好的亲子关系 宝宝的成长 婴儿成长的 5 个方面 养育聪明宝宝的 7 个方法 第 20 章 0～6个月：大变化 第 1 个月：需求多多 新生儿的反射动作 第 2 个月：笑容多多 第 3 个月：可爱的小手 对最初 3 个月的回顾 第 4 个月：视力更好 4～6个月的语言发展 第 5 个月：善于触摸 第 6 个月：学会好好坐 第 21 章 6～12个月：迅速发展 6～9 个月：探索大发现 新的恐惧和担心 9～12个月：大动作 照顾宝宝的脚 第 22 章 第2年：从婴儿到幼儿 12～15个月：迈出大步 15～18个月：说话 丰富幼儿的语言 孩子走路是不是怪怪的 18～24个月：思考能力 第 23 章 恼人但正常的幼儿行为 教育真正的含义 倔强的固定思维 为玩具而争吵 发脾气 咬和打 宝宝不听话 尖叫和哭哭啼啼 第 24 章 训练宝宝大小便 你应该知道的一些事情 晚训练比早训练好 逐步训练 不接受训练的孩子 大小便速成训练法：周末训练营 第 25 章 给宝宝安全的居家环境 容易发生意外的宝宝的特征 选用安全的婴儿用具 安全上路，旅途愉快 带宝宝骑自行车 你家的植物安全吗 环境污染：当心铅中毒 第 26 章 让宝宝健康不生病 保持健康从家开始 健康检查 接种疫苗 照顾小孩病 吃药 减少婴儿猝死综合征的出现 第 27 章 常见医学问题的家庭护理 发烧 感冒 咳嗽 耳部感染 鼻窦感染 哮吼 腹泻 呕吐 便秘 追踪和治疗吸入性过敏 湿疹 父母关于艾滋病的疑问 第 28 章常见紧急情况的急救和处理方法 提前准备，有备无患 异物窒息 如果孩子没有呼吸了：心肺复苏的步骤 流血 头部受伤 痉挛 烫伤 中毒 眼部受伤 鼻子受伤 昆虫叮咬 牙齿受伤 拉伤、扭伤和骨折 ","date":"2024-01-07T15:30:00Z","image":"https://yangzhaoxing90.github.io/p/%E8%A5%BF%E5%B0%94%E6%96%AF%E4%BA%B2%E5%AF%86%E8%82%B2%E5%84%BF/cover_hu6307248181568134095.jpg","permalink":"https://yangzhaoxing90.github.io/p/%E8%A5%BF%E5%B0%94%E6%96%AF%E4%BA%B2%E5%AF%86%E8%82%B2%E5%84%BF/","title":"西尔斯亲密育儿"},{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/hello-world/cover_hu6307248181568134095.jpg","permalink":"https://yangzhaoxing90.github.io/p/hello-world/","title":"Hello World"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/image-gallery/2_hu15576070775610481867.jpg","permalink":"https://yangzhaoxing90.github.io/p/image-gallery/","title":"Image gallery"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://yangzhaoxing90.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"https://yangzhaoxing90.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://yangzhaoxing90.github.io/p/shortcodes/cover_hu17063188895770243625.jpg","permalink":"https://yangzhaoxing90.github.io/p/shortcodes/","title":"Shortcodes"}]