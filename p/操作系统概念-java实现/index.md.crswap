---
title: 操作系统概念-Java实现
description: 《操作系统概念-Java实现》 读书笔记
slug: 操作系统概念-Java实现
date: 2025-02-27 00:00:00+0000
image: cover.png
categories:
    - 计算机
tags:
    - 操作系统
weight: 1       # You can add weight to some posts to override the default sorting (date descending)
---

## 概述

### 第1章 导论

**操作系统**是管理计算机硬件的程序,它还为应用程序提供基础，充当计算机硬件和用户之间的中介

本章目标：

- 概括介绍操作系统的主要组件
- 概括介绍计算机系统的基本组织体系结构

### 1.1 操作系统做什么

计算机系统可以粗分为 4 个组成部分：

- 计算机硬件 （如CPU、内存、IO设备），为系统提供基本的计算资源
- 操作系统  控制和协调用户的应用程序对硬件的使用
- 系统程序、应用程序 （如 word、浏览器），规定了按照何种方式使用资源解决用户的问题
- 用户


### 1.2 计算机系统组织


**计算机系统操作**


![计算机系统](computer.png)

电脑启动 -> 初始化程序 (位于固件中) -> 引导程序定位操作系统内核，并把它装入内存 -> 操作系统执行第一个进程，如 init -> 等待事件发生

事件的发送：

- 硬件中断 （随时通过系统总线向 CPU 发出信号，以触发中断）
- 软件中断 （通过执行系统调用）

![中断](break.png)

CPU 执行 IO 中断，然后又恢复原来的进程执行

不同的计算机有不同的中断机制，共同的点是，中断必须将控制权交给合适的**中断服务历程**

**存储结构**

![存储设备的层次](storage.png)

**IO结构**

通用计算机系统由一个CPU和多个**设备控制器组成**，它们通过共同的总线连接起来。每个设备控制器负责特定类型的设备

通常操作系统为每个设备控制器提供一个**设备驱动程序**，设备驱动程序理解设备控制器，提供设备和操作系统之间统一的接口

为了开始 IO 操作，设备驱动程序在设备控制器中装载适当的寄存器，设备控制器检查这些寄存器的内容，以确定执行什么操作

这种 IO 中断驱动适合移动少量数据，但对于大量数据的移动，会带来超载问题，**DMA （直接内存访问）** 就是为了解决这个问题设计的

![计算机内部工作](work.png)

### 1.3 计算机系统体系结构

- 单处理器系统
- 多处理器系统

### 1.4 操作系统结构

多道程序能力：

- 分时系统 （CPU 来回切换执行任务）

分时系统在主存储器中保存几个作业，作业最开始存在于磁盘的作业池中

操作系统通过作业调度从作业池中选择作业加载入内存，这一决策过程叫做 CPU 调度

分时操作系统中，操作系统必须保证合理的响应时间，这有时通过交换来得到，其中进程被换入内存或由内存换出到磁盘

虚拟内存（主要优点是程序可以比物理内存大）

分时系统也提供文件系统

### 1.5 操作系统操作

**双重模式操作**

- 用户模式
- 内核模式

可以区分操作系统所执行的任务和用户所执行的任务

双重模式操作为人们提供了保护操作系统和用户程序不受错误用户程序影响的手段

![双重模式操作](double.png)

实现方式为：将能引起损害的机器指令作为**特权指令**， 硬件允许特权指令仅在内核模式下执行

定时器：

必须确保操作系统能维持对CPU的控制，也必须防止用户程序陷入死循环或不调用系统服务，并且不将控制权返回到操作系统

可将定时器设置为在给定时间后中断计算机，时间可以是固定的，也可以是可变的

### 1.6 进程管理

处于执行中的程序被称为进程

进程需要一定的资源，CPU时间、内存、文件、I/O设备来完成其任务

操作系统负责管理进程的如下活动：

- 创建和删除用户进程和系统进程
- 挂起和重启进程
- 提供进程同步机制
- 提供进程通信机制
- 提供死锁处理机制

### 1.7 内存管理

内存是一个大的字或字节的数组，每个字或字节都有自己的地址

内存是可以被 CPU 和 I/O 设备所共同快速访问的数据仓库

操作系统负责下列有关内存的活动：

- 记录内存的哪部分正在被使用以及被谁使用
- 当有内存空间时，决定哪些进程可以装入内存
- 根据需要释放分配和释放内存空间

### 1.8 存储管理

操作系统对存储设备的物理属性进行了抽象，定义了逻辑存储单元，就是文件

文件是由其创建者定义的一组相关信息的集合 （程序和数据）

操作系统负责下列有关文件管理的活动：

- 创建和删除文件
- 创建和删除目录来组织文件
- 提供操作文件和目录的原语
- 将文件映射到二级存储上
- 在稳定（非易失的）存储介质上备份文件

现代大多数操作系统都采用硬盘作为主要在线存储介质来存储程序和数据

操作系统负责下列有关硬盘管理的活动：

- 空闲空间管理
- 存储空间分配
- 硬盘调度

### 1.9 保护和安全

保护是一种控制进程或用户对计算机系统资源访问的机制

绝大多数操作系统维护一种用户名和相关用户标识（UID）的链表，这些数值对用户来说是唯一的

### 1.10 分布式系统

分布式系统是一组物理上分开的、可能各个异构的计算机系统通过网络连接在一起，为用户提供系统所维护的各种资源的计算机的集合

### 1.11 专用系统

- 实时嵌入系统 （运行实时操作系统，有明确切固定的时间约束）
- 多媒体系统 （多媒体数据必须根据确定的时间限制来传输流）
- 手持系统 （）


### 1.12 计算环境

- 传统环境 
    - 批处理计算机系统，以批量的方式处理作业
    - 分时系统采用定时器和调度算法，通过CPU迅速地循环进程，给其中每一个用户分配资源
- 客户-服务器计算
- 对等计算
- 基于 web 计算

## 第 2 章 操作系统结构

本章目标：

- 介绍操作系统为用户、进程和其他系统提供的服务
- 讨论组织操作系统的不同方法
- 解释如何安装、定制操作系统，以及如何启动操作系统

### 2.1 操作系统服务

一组操作系统服务提供对用户很有用的功能：

- 用户界面 （GUI、CLI、批界面）
- 程序执行 （系统必须能将程序装入内存并运行该程序）
- I/O操作 （运行程序需要的 IO）
- 文件系统操作 （读写文件和目录）
- 通信 （进程间交换信息）
- 错误检测 
- 资源分配 （多个用户或作业运行时，需要分配资源）
- 统计 （记录哪些用户使用了哪些资源）
- 保护和安全

### 2.2 操作系统的用户界面

- 命令解释程序
- 图形用户界面

### 2.3 系统调用

系统调用是获取操作系统所提供的服务的接口

应用程序员最常用的 API 有三种：

- Win32 API （Windows 系统）
- POSIX API （Unix、Linux 和 Mac OS X）
- Java API （JVM）

用 API 不用实际系统调用的好处：

- 可移植性强
- 实际的系统调用比 API 难用且更复杂

![系统调用](systemcall.png)


### 2.4 系统调用类型

系统调用可以分为 5 大类：

- 进程控制 （结束、放弃、装入、执行、创建进程、终止进程、取得进程属性、设置进程属性、等待时间、等待事件、唤醒事件、分配和释放内存）
- 文件管理 （创建文件、删除文件、打开、关闭、读、写、重定位、取得文件属性、设置文件属性）
- 设备管理 （请求设备、释放设备、读、写、重定位、取得设备属性、设置设备属性、逻辑连接或断开设备）
- 信息维护 （读取时间或日期、设置时间或日期、读取系统数据、设置系统数据、读取进程，文件或设备属性、设置进程，文件或设备属性）
- 通信 （创建，删除通信连接、发送，接收消息、传递状态信息、连接或断开远程设备）



**通信**

两种常见的通信模型：

- 消息传递模型 （通信进程通过交换消息来传递信息）
- 共享内存模型 （通过 shared memory create 和 shared memory attach 系统调用来获得其他进程所拥有的内存区域访问权）

### 2.5 系统程序

可以分为分类：

- 文件管理
- 状态信息
- 文件修改
- 程序设计语言支持
- 程序装入和执行
- 通信


### 2.6 操作系统设计和实现

**策略和机制的分离**

机制决定了如何做，策略决定做什么

### 2.7 操作系统结构

MS-DOS 结构

![MS-DOS结构](msdos.png)

分层结构

![分层结构](layer.png)

模块结构

- 调度类
- 文件系统
- 可加载的系统调用
- 可执行的格式
- STREAMS 模块
- 杂项模块
- 设备和总线驱动程序

### 2.8 虚拟机

虚拟机的基本思想是单个计算机的硬件抽象为几个不同的执行环境

### 2.9 Java

Java 技术包含三个核心组件：

- 编程语言规范
- 应用程序接口 （API）
- 虚拟机规范


### 2.10 操作系统生成

下面的信息必须确定下来：

- 使用什么 CPU，安装什么选项，对于多 CPU 系统，必须描述每个 CPU
- 有多少可用内存
- 有什么可用设备
- 需要什么操作系统选项或使用什么参数值


### 2.11 系统启动

## 第二部分 进程管理

### 第 3 章 进程

本章目标：

- 介绍进程的概念——执行中的程序，形成所有计算的基础
- 介绍进程的不同特点，包括调度、创建和终止以及通信
- 介绍客户机——服务机系统内的通信

### 3.1 进程概念

进程：

- 程序代码 （文本段 text section）
- 活动 （程序计数器的值和处理器寄存器的内容）
- 进程栈（包括临时数据，函数参数、返回地址、局部变量）
- 数据段 （data section）
- 堆 （heap），进程在运行期间动态分配的内存


![内存中的堆](heap.png)

进程的状态：

- 新建
- 运行
- 等待
- 就绪
- 终止

![进程的状态](status.png)

进程控制块 (PCB)

- 进程状态 
- 程序计数器 （表示下一个指令执行的地址）
- CPU 寄存器 
- CPU 调度信息 （进程优先级、调度队列的指针和其他调度参数）
- 内存管理信息 （基址和界限寄存器的值、页表或段表）
- 记账信息 （CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量）
- I/O 状态信息 （I/O设备列表、打开文件列表等）


![CPU进程间切换](process.png)

### 3.2 进程调度

调度队列： 进程进入系统时，会被加到作业队列中，该队列中包含所有的进程

新进程开始处于就绪队列，它就在队列中等待直到被选中执行或分派

当进程分配到 CPU 并执行时，可能发生下面几种事件中的一种：

- 进程可能发出一个 I/O 请求，并被放到 I/O 队列中
- 进程可能创建一个新的子进程，并等待结束
- 进程可能会由于中断而强制释放 CPU， 并被放回就绪队列

![队列图](queue.png)

调度程序：从队列中选择进程的程序

上下文切换：CPU从一个进程切换到另一个进程

- 内核将旧进程的内容保存到 PCB 中
- 装入经调度要执行的已保存的新进程的上下文

### 3.3 进程操作

进程创建：

- 系统调用创建进程，父子进程，进程树，进程唯一标识

![进程树](tree.png)

当进程创建进程时，有两种可能：

- 父进程与子进程并发执行
- 父进程等待，直到某个或全部子进程执行完毕

新进程的地址空间也有两种可能：

- 子进程是父进程的副本
- 子进程装入一个新程序

进程终止：

- exit()请求操作系统删除自身
- 子进程可以返回状态到父进程

父进程终止子进程的原因：

- 子进程使用了超过它所分配到的一些资源
- 分配给子进程的任务已不再需要
- 父进程结束，若父进程终止，操作系统将不允许子进程继续

### 3.4 进程间的通信

允许进程协作的理由：

- 信息共享 （并发访问一个资源）
- 加快计算 
- 模块化
- 方便 （单用户可以执行多任务）

进程通信的两个基本模型：

- 共享内存
- 消息传递

![通信模型](model.png)

共享内存模型：

- 生产者 —— 消费者问题
- 无限缓冲区 （消费者要等待新的项，生产者总可以产生新的项）
- 有限缓冲区 （如果缓冲区为空，消费者必须等待。如果缓冲区满，生产者必须等待）

消息传递模型：

- 消息传递工具 （必须提供发送和接收功能）
- 若进程间要彼此发送消息和接收消息，它们间必须有通信链路

实现链路发送和接收操作的方法：

- 直接或间接通信
- 同步或异步通信
- 自动或显式缓冲

直接通信：

- 必须明确的命名通信的接收者或者发送者 （对称寻址）
    - send(P, message): 发送消息到 P 
    - receive(Q, message): 接收来自 Q 的消息
    - 通信链路要求
        - 在需要通信的每队进程间自动建立通信链路，进程只需要知道互相的标识符
        - 一个通信链路只与两个进程相关
        - 每队进程间只有一个通信链路
- 只需要发送者命名接收者，不需要接收者命名发送者 （非对称寻址）
    - send(P, message): 发送消息到 P
    - receive(id, message): 接收来自任何进程的消息，变量 id 设置成与其通信的进程名称


间接通信：

- 通过邮箱和端口来发送和接收消息
- 邮箱可以抽象成一个对象，进程可以向其中存放消息，也可以从中删除消息
- 每个邮箱都有一个唯一标识
    - send(A, message): 发送一个消息到邮箱 A
    - receive(A, message): 接收来自邮箱 A 的消息
    - 通信链路要求
        - 只有在两个进程共享一个邮箱的时候才能建立通信链路
        - 一个链路可以和两个或者更多的进程相关联
        - 两个通信进程之间可以有多条不同的链路，每条链路对应于一个邮箱

假设 P1、P2、P3 都共享邮箱，P1 发送消息到邮箱，P2 和 P3 谁能接收到信息，由系统定义决定：

- 允许一个链路最多只能与两个进程相关联
- 允许一次最多一个进程执行 receive() 操作
- 允许系统随意选择一个进程接收消息

邮箱可以为进程所拥有：

- 进程地址空间的一部分
- 进程终止时，邮箱消失，往邮箱发送消息会被通知邮箱不存在


邮箱也可以为操作系统所拥有，操作系统必须提供的机制：

- 创建新邮箱 （创建的进程默认为进程拥有者）
- 通过邮箱发送和接收消息
- 删除邮箱

send、receive 原语实现有不同的设计选项（同步-阻塞、异步-非阻塞）：

- 阻塞发送
- 非阻塞发送
- 阻塞接收
- 非阻塞接收


通信进程所交换的消息都驻留在临时队列中，队列实现的3个方法：

- 零容量
- 有限容量
- 无限容量


### 3.5 IPC 系统的实例

### 3.6 客户机 —— 服务器通信

三种客户机——服务器通信方法：

- 套接字 （socket），比较低级的分布式进程通信，只允许通信线程交换无结构字节流。
- 远程过程调用 （RPC）
- Java的远程方法调用（RMI）

## 第 4 章 线程

本章目标：

- 引入线程的概念 —— 一种 CPU 利用的基本单元，它是形成多线程计算机的基础
- 讨论 Pthread API 、Win32 API 和 Java 线程库
- 研究有关多线程编程的几个问题

### 4.1 概述

线程是 CPU 使用的基本单元，由线程ID、程序计数器、寄存器集合和栈组成

![线程](thread.png)

### 4.2 多线程模型

线程支持的两种方法：

- 用户层的用户线程
- 内核层的内核线程

![一对多](user_model.png)

![一对一模型](one_model.png)

![多对多模型](multiple.png)

### 4.3 线程库

线程库为程序员提供创建和管理线程的 API

两种方法实现线程库：

- 在用户空间中提供一个没有内核支持的库
- 执行一个由操作系统直接支持的内核级的库

三种线程库：

- POSIX Pthread （Unix/Linux）
- Win32 （Windows）
- Java （利用前两个）

### 4.4 Java 线程

Java 线程状态：

- 新建
- 可运行
- 阻塞
- 死亡

![java 线程](java_thread.png)

### 4.5 多线程问题

线程取消：

- 是在线程完成之前终止线程的任务
- 异步取消 （立即终止目标线程）
- 延迟取消 （目标线程不断的检查它是否应终止）

信号处理：

- 信号在 Unix 中用于通知进程某个特定事件的发生
- 信号模式：
    - 信号是由特定事件的发生所产生的
    - 产生的信号要发送到进程
    - 一旦发送，信号必须加以处理

线程池：

- 单线程执行器 （大小为 1 的线程池）
- 固定线程执行器 （大小固定的线程池）
- 缓冲线程执行器 （无限制的线程池）

线程特定数据：

- 每个线程需要一定的数据自我副本 （）
